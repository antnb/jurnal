---
layout: full_article
title: "Comparative Analysis of Background Subtraction, Haar Cascade and SSD Methods in Detecting Cars"
author: "Tristan Nugraha Tanaya, I Gusti Ngurah Anom Cahyadi Putra"
categories: jnatia
canonical_url: https://jurnal.harianregional.com/jnatia/full-92838 
citation_abstract_html_url: "https://jurnal.harianregional.com/jnatia/id-92838"
citation_pdf_url: "https://jurnal.harianregional.com/jnatia/full-92838"  
comments: true
---

<p><span class="font1">JNATIA Volume 1, Nomor 1, November 2022</span></p>
<p><span class="font1">Jurnal Nasional Teknologi Informasi dan Aplikasinya</span></p><a name="caption1"></a>
<h2><a name="bookmark0"></a><span class="font3" style="font-weight:bold;"><a name="bookmark1"></a>Comparative Analysis of Background Subtraction, Haar Cascade and SSD Methods in Detecting Cars</span></h2>
<p><span class="font1">Tristan Nugraha Tanaya<sup>a1</sup>, I Gusti Ngurah Anom Cahyadi Putra, ST., M.Cs<sup>a2</sup></span></p>
<p><span class="font1"><sup>12</sup> Program Studi Informatika, Fakultas Matematika dan Ilmu Pengetahuan Alam ,Universitas Udayana</span></p>
<p><span class="font1">Jl. Raya Kampus UNUD, Bukit Jimbaran, Kuta Selatan, Badung, Bali</span></p>
<p><span class="font1">,Indonesia</span></p>
<p><a href="mailto:1tristan.tanaya@gmail.com"><span class="font1"><sup>1</sup>tristan.tanaya@gmail.com</span></a></p>
<p><a href="mailto:2anom.cp@unud.ac.id"><span class="font1"><sup>2</sup>anom.cp@unud.ac.id</span></a></p>
<p><span class="font1" style="font-weight:bold;font-style:italic;">Abstract</span></p>
<p><span class="font1" style="font-style:italic;">This research was conducted to detect and count cars that are passing on the highway quickly. In this study, 3 methods will be applied, namely the Background Subtraction, Haar Cascade, and Single Shot Detector (SSD) methods. This study will compare the best methods for calculating cars on the highway. Based on the results of research using the Haar Cascade method, the results are quite good compared to other methods. But using these three methods the author has not gotten satisfactory results. Due to many factors that cause this comparison is not satisfactory. Starting with simple coding, poor video quality is also one of the factors that this research is unsatisfactory</span><span class="font0">.</span></p>
<p><span class="font1" style="font-weight:bold;font-style:italic;">Keywords: </span><span class="font1" style="font-style:italic;">Background Subtraction, Haar Cascade, Single Shot Detector (SSD), Car, Comparison</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark2"></a><span class="font1" style="font-weight:bold;"><a name="bookmark3"></a>1. &nbsp;&nbsp;&nbsp;Introduction</span></h4></li></ul>
<p><span class="font1">Seiring meningkatnya pertumbuhan jumlah penduduk setiap tahunnnya, maka jumlah kendaraan akan semakin banyak. Di kota-kota besar sangat sering sekali terjadi kemacetan karena kendaraan yang ada sangat tidak sebanding dengan fasilitas jalan raya yang ada.pertumbuhan jumlah kendaraan akan menyebabkan kemacetan. Untuk menentukan kepadatan lalu-lintas diperlukan adanya survey untuk perhitungan jumlah kendaraan yang melintas. Survey ini dilakukan oleh seorang pengamat atau peneliti. Namun, seorang peneliti bisa salah dalam melakukan proses penghitungan dan bakal terjadi </span><span class="font1" style="font-style:italic;">human error.</span><span class="font1"> Sehingga pelaksanaan survey kurang efisien. Berdasarkan permasalahan tersebut, maka perlu dlakukan penelitian untuk menghitung jumlah mobil yang menggunakan fasilitas jalan raya. Dalam penelitian ini penulis akan melakukan perbandingan antara metode </span><span class="font1" style="font-style:italic;">background subtraction, haar cascade</span><span class="font1">, dan </span><span class="font1" style="font-style:italic;">SSD. </span><span class="font1">Metode </span><span class="font1" style="font-style:italic;">background subtraction</span><span class="font1"> atau juga dikenal sebagai deteksi tepi adalah suatu proses yang menghasilkan tepi-tepi dari objek-objek untuk proses segmentasi dan identifikasi objek, tujuannya adalah untuk melacak titik-titik yang dianggap sebagai tepi dari suatu objek yang mebatasi suatu wilayah objek satu dengan lainnya. Metode </span><span class="font1" style="font-style:italic;">haar cascade</span><span class="font1"> adalah mengenali objek berdasarkan nilai sederhana dari fitur tetapi bukan merupakan nilai piksel dari image objek tersebut. Metode ini merupakan metode yang menggunakan statistical model (</span><span class="font1" style="font-style:italic;">classifier</span><span class="font1">) pendekatan untuk mendeteksi objek dalam gambar menggabungka tiap kunci utam yaitu </span><span class="font1" style="font-style:italic;">Haar like Feature, Internal Image, Adaboost learning, dan Cascade classifier</span><span class="font1">. Metode </span><span class="font1" style="font-style:italic;">Single Shot Detector</span><span class="font1"> (SSD) yang terintegrasi dengan dataset dari MobleNet-SSD. Integrasi tersebut mampu untuk mendeteksi objek dari data input yang berasal dari hasil rekaman kamera. </span><span class="font1" style="font-style:italic;">Single Shot Detector</span><span class="font1"> (SSD) adalah algoritma yang dapat mendeteksi objek dalam sebuah gambar atau video dan meiliki akurasi yang lebih tinggi. Penulis akan membandingkan dari ketiga metode tersebut untuk mencari yang paling efektif dan akurat untuk menghitung mobil yang berada di jalan raya. Penelitian ini dibantu dengan menggunakan aplikasi jupyter notebook dan menghasilkan proses penghitungan mobil.</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark4"></a><span class="font1" style="font-weight:bold;"><a name="bookmark5"></a>2. &nbsp;&nbsp;&nbsp;Reseach Methods</span><br><br><span class="font1" style="font-weight:bold;"><a name="bookmark6"></a>2.1. &nbsp;&nbsp;&nbsp;OpenCV</span></h4></li></ul>
<p><span class="font1">OpenCV (</span><span class="font1" style="font-style:italic;">Open Source Computer Vision Library</span><span class="font1">) adalah library dari fungsi pemrograman untuk realtime visi computer [1]. OpenCV menggunakan lisensi BSD dan bersifat gratis baik untuk penggunaan akademis maupun komersial. OpenCV dapat digunakan dalam Bahasa pemrograman C, C++, Python, java, dan sebagainya [2]. Di OpenCV, kata Open dipahami sebagai open source gratis, tidak berbayar, dan siapa pun dapat mengunduhnya sedangkan CV sendiri merupakan singkatan dari Computer Vision yang artinya computer digunakan untuk mengolah gambar yang diambil oleh alat perekam. Tujuan OpenCV ini diantaranya untuk memperbaiki kualitas gambar atau untuk mengindentifikasi gambar.[3]</span></p><img src="https://jurnal.harianregional.com/media/92838-1.jpg" alt="" style="width:131pt;height:83pt;"><a name="caption2"></a>
<h1><a name="bookmark7"></a><span class="font4" style="font-weight:bold;"><a name="bookmark8"></a>OpenCV</span></h1>
<p><span class="font1" style="font-weight:bold;">Figure 1. </span><span class="font1">OpenCV</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark9"></a><span class="font1" style="font-weight:bold;"><a name="bookmark10"></a>2.2. &nbsp;&nbsp;&nbsp;Python</span></h4></li></ul>
<p><span class="font1">Phyton adalah Bahasa pemrograman yang popular di seluruh dunia yang digunakan untuk mengembangkan situs web dan algoritma. Bahasa pemrograman python membuat program apapun lebih sederhana daripada Bahasa pemrograman yang lainnya.</span></p><img src="https://jurnal.harianregional.com/media/92838-2.jpg" alt="" style="width:397pt;height:252pt;">
<ul style="list-style:none;"><li>
<h4><a name="bookmark11"></a><span class="font1" style="font-weight:bold;"><a name="bookmark12"></a>2.3.1. &nbsp;Pre-Processing</span></h4></li></ul>
<p><span class="font1">Dalam tahap ini dilakukan proses pengubahan data mentah yang diambil dari kamera menjadi bentuk yang dapat dimengerti oleh komputer. Dalam tahap ini juga dilakukan noise removal dan eliminasi objek kecil pada gambar [4].</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark13"></a><span class="font1" style="font-weight:bold;"><a name="bookmark14"></a>2.3.2. &nbsp;&nbsp;&nbsp;Background Modelling</span></h4></li></ul>
<p><span class="font1">Latar Belakang yang digunakan dalam proses ini merupakan latar belakang yang terdapat di video. Citra latar belakang yang diambil adalah latar belakang yang tidak ada objek dan dilakukan secara manual. latar belakang yang diambil ini bersifat statis yaitu tidak berpindah tempat maupun bergerak. Penerapan teknik statis ini lebih efisien dibandingkan dengan penerapan teknik adaptif.[5]</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark15"></a><span class="font1" style="font-weight:bold;"><a name="bookmark16"></a>2.3.3. &nbsp;&nbsp;&nbsp;Foreground Detection</span></h4></li></ul>
<p><span class="font1">Proses ekstraksi foreground dari background dilakukan dalam tahap ini. proses ini memiliki persamaan matematis yaitu:</span></p>
<p><span class="font9" style="font-style:italic;">R<sub>r</sub></span><span class="font7" style="font-style:italic;">,c</span><span class="font9"> = </span><span class="font9" style="font-style:italic;">I</span><span class="font7" style="font-style:italic;">r,c</span><span class="font7"> <sup>-</sup> </span><span class="font9" style="font-style:italic;">B</span><span class="font7" style="font-style:italic;"><sub>r</sub>,c</span><span class="font1"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)</span></p>
<p><span class="font1">Ket</span></p>
<p><span class="font1">R = hasil</span></p>
<p><span class="font1">I = gambar saat ini</span></p>
<p><span class="font1">B = background model r = baris c = kolom</span></p>
<p><span class="font1">Nilai R lalu dibandingkan dengan nilai </span><span class="font1" style="font-style:italic;">threshold</span><span class="font1"> yang telah ditentukan, jika lebih besar dari nilai </span><span class="font1" style="font-style:italic;">threshold</span><span class="font1"> maka piksel di I(r,c) dapat dianggap berbeda dengan piksel di B(r,c).[4]</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark17"></a><span class="font1" style="font-weight:bold;"><a name="bookmark18"></a>2.3.4. &nbsp;&nbsp;&nbsp;Object Detection</span></h4></li></ul>
<p><span class="font1">Tahap ini yaitu mendeteksi dan menemukan adanya pergerakan dari objek di setiap frame. Tahap ini memakai metode </span><span class="font1" style="font-style:italic;">Kalman filter</span><span class="font1"> dan algoritma </span><span class="font1" style="font-style:italic;">blob analysis</span><span class="font1">. </span><span class="font1" style="font-style:italic;">Kalman filter</span><span class="font1"> (KF) adalah suatu metode estimasi keadaan yang dapat diimplementasikan pada model dinamik linear saja.[6] </span><span class="font1" style="font-style:italic;">Blob analysis</span><span class="font1"> adalah pendeteksi pixel-pixel yang memiliki warna sama dibandingkan latar belakangnya. Pendeteksi ini bertujuan untuk mendeteksi </span><span class="font1" style="font-style:italic;">low-level</span><span class="font1"> di suatu objek dua diemnsi maupun tiga dimensi. [7]</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark19"></a><span class="font1" style="font-weight:bold;"><a name="bookmark20"></a>2.3.5. &nbsp;&nbsp;&nbsp;Noise removal dan Hole Filling</span></h4></li></ul>
<p><span class="font1">Dilakukan proses </span><span class="font1" style="font-style:italic;">noise removal</span><span class="font1"> dan </span><span class="font1" style="font-style:italic;">hole filling</span><span class="font1"> pada citra. Citra hasil perlu dilakukan </span><span class="font1" style="font-style:italic;">noise removal</span><span class="font1"> agar lebih baik. Selanjutnya hasil citra juga dilakukan proses </span><span class="font1" style="font-style:italic;">filling</span><span class="font1"> karena masih terdapat banyak lubang </span><span class="font1" style="font-style:italic;">hole. Filling</span><span class="font1"> dilakukan dengan menutupi lubang-lubang kecil pada citra agar citra menjadi lebih halus. Proses </span><span class="font1" style="font-style:italic;">noise removal</span><span class="font1"> dan </span><span class="font1" style="font-style:italic;">hole filling</span><span class="font1"> ini menggunakan Operasi Morfologi.[4]</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark21"></a><span class="font1" style="font-weight:bold;"><a name="bookmark22"></a>2.3.6. &nbsp;&nbsp;&nbsp;Object Classification dan Pedestrian Annotation</span></h4></li></ul>
<p><span class="font1">Tahap ini merupakan tahap untuk membedakan dimana objek dan dimana yang bukan objek. Pada tahap ini dilakukan seleksi pada objek dengan melihat ukuran setiap objek. Ukuran tersebut didapat dari mendeteksi </span><span class="font1" style="font-style:italic;">boundary</span><span class="font1"> dari setiap objek yang terdeteksi. </span><span class="font1" style="font-style:italic;">Boundary</span><span class="font1"> pada objek bertujuan untuk mendeteksi 1 objek serta beberapa objek yang berdekatan dengan lebih akurat. Setelah melalui tahap klasifikasi objek, objek akan dibingkai dengan kotak berwarna hijau. Kotak tersebut didapat dari nilai garis batas terluar dari objek. [4]</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark23"></a><span class="font1" style="font-weight:bold;"><a name="bookmark24"></a>2.3.7. &nbsp;&nbsp;&nbsp;Object Counting</span></h4></li></ul>
<p><span class="font1">Pada tahap akhir yaitu menghitung berapa jumlah objek yang terdeteksi. Jumlah tersebut didapat dari objek yang melewati garis.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font5" style="font-weight:bold;">2.4.</span><span class="font1" style="font-weight:bold;"> &nbsp;&nbsp;&nbsp;Contour</span></p></li></ul>
<p><span class="font1" style="font-style:italic;">Contour</span><span class="font1"> adalah sebuah list yang berisi point yang dapat dikatakan mewakili dalam suatu curva dari sebuah gambar. </span><span class="font1" style="font-style:italic;">Contour</span><span class="font1"> digambarkan dalam </span><span class="font1" style="font-style:italic;">OpenCV</span><span class="font1"> sebagai urutan (</span><span class="font1" style="font-style:italic;">sequence</span><span class="font1">) informasi yang dikodekan tentang lokasi dari point berikutnya dalam kurva. Fungsi yang ada pada </span><span class="font1" style="font-style:italic;">OpenCV</span><span class="font1">, menghitung </span><span class="font1" style="font-style:italic;">contour</span><span class="font1"> dari gambar biner. Gambar biner dapat dihasilkan dari suatu </span><span class="font1" style="font-style:italic;">threshold</span><span class="font1"> yang memiliki sudut yang implisit sebagai batas antara area yang positif dan negatif. [8]</span></p>
<div><img src="https://jurnal.harianregional.com/media/92838-3.jpg" alt="" style="width:104pt;height:107pt;">
<p><span class="font1" style="font-weight:bold;">Figure 3. </span><span class="font1">Contour pada OpenCV</span></p>
</div><br clear="all">
<p><span class="font1">Beberapa tahapan yang harus dilalui apabila ingin mendapatkan contour dari gambar RGB. Tahapannya adalah :</span></p>
<ul style="list-style:none;"><li>
<p><span class="font1">1. &nbsp;&nbsp;&nbsp;Membalikkan warna citra (</span><span class="font1" style="font-style:italic;">negative color</span><span class="font1">)</span></p></li>
<li>
<p><span class="font1">2. &nbsp;&nbsp;&nbsp;Membuat gambar menjadi citra keabuan (</span><span class="font1" style="font-style:italic;">gray scale</span><span class="font1">)</span></p></li>
<li>
<p><span class="font1">3.</span><span class="font1" style="font-style:italic;"> &nbsp;&nbsp;&nbsp;Thresholding</span><span class="font1"> dengan </span><span class="font1" style="font-style:italic;">threshold binary</span><span class="font1">. Operasi </span><span class="font1" style="font-style:italic;">thresholding</span><span class="font1"> dapat dihitung dengan</span></p></li></ul>
<p><span class="font9">, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, f'</span><span class="font9" style="font-style:italic;">maxVal, if src(x,y) &gt;&nbsp;thres</span></p>
<div>
<p><span class="font8">(2)</span></p>
</div><br clear="all">
<p><span class="font9" style="font-style:italic;">dst(x,y) =</span><span class="font9"> {</span></p>
<p><span class="font9" style="font-style:italic;">( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, other-wise</span></p>
<ul style="list-style:none;"><li>
<p><span class="font1">4. &nbsp;&nbsp;&nbsp;Menentukan </span><span class="font1" style="font-style:italic;">contour</span><span class="font1"> dari gambar</span></p></li></ul>
<ul style="list-style:none;"><li>
<h4><a name="bookmark25"></a><span class="font5" style="font-weight:bold;"><a name="bookmark26"></a>2.5.</span><span class="font1" style="font-weight:bold;"> &nbsp;&nbsp;&nbsp;Haar Cascade Classifier</span></h4></li></ul>
<p><span class="font1" style="font-style:italic;">Haar like feature</span><span class="font1"> atau yang dikenal sebagai </span><span class="font1" style="font-style:italic;">Haar Cascade Classifier</span><span class="font1"> merupakan </span><span class="font1" style="font-style:italic;">rectangular feature</span><span class="font1">, yang memberikan indikasi secara spesifik pada sebuah gambar atau image. Metode ini berasal dari gagasan Paul Viola dan Michael Jhon, karena itu dinamakan metode Viola &amp;&nbsp;Jhon. Ide dari Haar like feature adalah mengenali obyek berdasarkan nilai sederhana dari fitur tetapi bukan merupakan nilai piksel dari image obyek tersebut. Metode ini memiliki kelebihan yaitu komputasi yang sangat cepat, karena hanya tergantung pada jumlah piksel dalam persegi bukan setiap nilai piksel dari sebuah image. Metode ini merupakan metode yang menggunakan statistikal model (</span><span class="font1" style="font-style:italic;">classifier</span><span class="font1">). [9]</span></p><img src="https://jurnal.harianregional.com/media/92838-4.jpg" alt="" style="width:249pt;height:162pt;">
<p><span class="font1" style="font-weight:bold;">Figure 4. </span><span class="font1">Haar Like Features</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark27"></a><span class="font1" style="font-weight:bold;"><a name="bookmark28"></a>2.6. &nbsp;&nbsp;&nbsp;Single Shot Detector</span></h4></li></ul>
<p><span class="font1" style="font-style:italic;">Single Shot Detector</span><span class="font1"> (SSD) adalah sebuah metode untuk mengenali atau mendeteksi sebuah objek pada suatu gambar dengan menggunakan </span><span class="font1" style="font-style:italic;">single deep neural network</span><span class="font1"> dan salah satu algoritma deteksi objek yang paling populer karena kemudahan implementasi, serta akurasi yang baik relatif terhadap komputasi yang dibutuhkan [10]. Metode </span><span class="font1" style="font-style:italic;">Single Shot Detector </span><span class="font1">(SSD) ini termasuk kedalam deteksi object secara </span><span class="font1" style="font-style:italic;">real time</span><span class="font1">. Arstitektur SSD termasuk kedalam jenis </span><span class="font1" style="font-style:italic;">Convolutation Neural Network</span><span class="font1"> (CNN) [11], yang merupakan salah satu jenis </span><span class="font1" style="font-style:italic;">Neural Network</span><span class="font1"> yang biasa digunakan pada data image. Arsitektur dari CNN dibagi menjadi 2 bagian besar</span><span class="font1" style="font-style:italic;">, Feature Extraction Layer</span><span class="font1"> dan </span><span class="font1" style="font-style:italic;">Convolutional Layer</span><span class="font1">. Dimana pada bagian </span><span class="font1" style="font-style:italic;">Feature Extraction Layer</span><span class="font1"> ini adalah melakukan </span><span class="font1" style="font-style:italic;">encoding</span><span class="font1"> dari sebuah image menjadi </span><span class="font1" style="font-style:italic;">features </span><span class="font1">yang merepresentasikan gambar tersebut. Sedangkan bagian </span><span class="font1" style="font-style:italic;">Convolutional Layer</span><span class="font1"> terdiri dari neuron yang tersusun sedemikian rupa sehingga membentuk sebuah filter dengan panjang dan tinggi (</span><span class="font1" style="font-style:italic;">pixels</span><span class="font1">).</span></p>
<p><span class="font1" style="font-style:italic;">Dataset</span><span class="font1"> pada penelitian menggunakan model pendeteksian objek </span><span class="font1" style="font-style:italic;">SSDLite-MobileNet-v2 </span><span class="font1">terkuantisasi yang dilatih dari </span><span class="font1" style="font-style:italic;">set data Common Object in Context Detection Challenge </span><span class="font1">(COCO) [11] dan dikonversi yang telah disimpan pada ruang penyimpan </span><span class="font1" style="font-style:italic;">Raspberry Pi</span><span class="font1">. Dan dataset tersebut digunakan untuk klasifikasi objek. Dataset ini telah meliputi 90 jenis objek, mulai dari manusia, hewan (kucing, anjing, kuda, dsb.), serta benda (mobil, kursi, meja, dsb.) Secara umum metode </span><span class="font1" style="font-style:italic;">Single Shot Detector</span><span class="font1"> (SSD) mempunyai sebuah rumus sederhana dalam menentukan </span><span class="font1" style="font-style:italic;">default boxes</span><span class="font1"> dan </span><span class="font1" style="font-style:italic;">scale default boxes</span><span class="font1">.</span></p>
<p><span class="font1">Untuk menentukan </span><span class="font1" style="font-style:italic;">default boxes</span></p>
<p><span class="font7">1</span></p>
<p><span class="font9" style="font-style:italic;">L(‰c,l,ζf) &nbsp;&nbsp;&nbsp;~ (L<sub>coγi</sub></span><span class="font7" style="font-style:italic;">f</span><span class="font9" style="font-style:italic;">(x,c} + ccL</span><span class="font7" style="font-style:italic;">ι</span><span class="font9" style="font-style:italic;"><sub>0</sub></span><span class="font7" style="font-style:italic;">c</span><span class="font9" style="font-style:italic;">(X'l,gy) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font1" style="font-style:italic;">(3)</span></p>
<p><span class="font1">Untuk menentukan </span><span class="font1" style="font-style:italic;">scale default boxes</span></p>
<p><span class="font9" style="font-style:italic;">s<sub>k</sub></span><span class="font9"> = </span><span class="font9" style="font-style:italic;">S<sub>mi</sub></span><span class="font7" style="font-style:italic;">γ</span><span class="font9"> + &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font6">' </span><span class="font9" style="font-style:italic;">(k </span><span class="font9" style="font-style:italic;font-variant:small-caps;">-d,</span><span class="font9" style="font-style:italic;"> ke</span><span class="font9"> [1, </span><span class="font9" style="font-style:italic;">m]</span><span class="font1"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)</span></p>
<p><span class="font7" style="font-style:italic;">m — 1</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark29"></a><span class="font1" style="font-weight:bold;"><a name="bookmark30"></a>3. &nbsp;&nbsp;&nbsp;Result and Discussion</span><br><br><span class="font1" style="font-weight:bold;"><a name="bookmark31"></a>3.1. &nbsp;&nbsp;&nbsp;Algoritma Background Substraction</span></h4></li></ul>
<p><span class="font1">Algoritma Background Substraction mendeteksi objek mobil dengan cara membandingkan gambar yang memiliki objek dengan gambar latar belakang yang tidak memiliki objek. Video rekaman dimasukkan ke syntax dan diproses untuk mendeteksi mobil. Dalam algoritma ini mendeteksi semua gerakan yang ada di dalam rekaman tersebut menjadi contour dapat dilihat di gambar no. 5. Namun, tidak semua gerakan terhitung sebagai mobil karena hanya objek yang melewati garis biru yang akan terdeteksi sebagai mobil dan akan terhitung pada</span></p>
<p><span class="font1">system. Objek yang bergerak tersebut akan dikelilingi dengan box berwarna hijau dan ditengah box hijau terdapat titik merah dapat dilihat di gambar no. 6. System akan menghitung objek itu sebagai mobil jika titik merah yang berada di tengah-tengah box berwarna hijau melewati garis biru. Hasil yang didapatkan adalah 325 mobil.</span></p><img src="https://jurnal.harianregional.com/media/92838-5.jpg" alt="" style="width:278pt;height:154pt;">
<p><span class="font1" style="font-weight:bold;">Figure 5. </span><span class="font1">Background Subtraction</span></p><img src="https://jurnal.harianregional.com/media/92838-6.jpg" alt="" style="width:278pt;height:155pt;">
<p><span class="font1" style="font-weight:bold;">Figure 6. </span><span class="font1">Video Background Subtraction</span></p><img src="https://jurnal.harianregional.com/media/92838-7.jpg" alt="" style="width:278pt;height:156pt;">
<p><span class="font1" style="font-weight:bold;">Figure 7. </span><span class="font1">Hasil Background Subtraction</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark32"></a><span class="font1" style="font-weight:bold;"><a name="bookmark33"></a>3.2. &nbsp;&nbsp;&nbsp;Haar Cascade Classification</span></h4></li></ul>
<p><span class="font1">Pada tahapan penelitian ini dimulai dengan mamasukkan file cars.xml kedalam syntax. Tahap selanjutnya memasukkan video original ke dalam syntax. Pada proses pendeteksian objek mobil dengan menggunakan metode Haar Cascade Classifier, ada beberapa proses yang dilakukan sebelum akhirnya akan menghasilkan sebuah output objek mobil yang</span></p>
<p><span class="font1">terdeteksi pada sebuah video. Sama seperti metode sebelumnya dalam menghitung mobil yang berada dalam video tersebut. Mobil akan dikelilingi box berwarna hijau dan ditengah-tengah box tersebut terdapat titik merah yang menandakan bahwa yang dikelilingi box hijau tersebut adalah objek mobil dapat dilihat di gambar no. 8. Penghitungan objek mobil juga sama seperti metode sebelumnya jika titik merah yang ada didalam box berwarna hijau itu melewati garis biru maka mobil akan terhitung ke dalam system. Namun, penulis melihat kekurangan dari metode ini bisa dilihat di gambar 8. Objek yang bukan mobil tetap terdeteksi sebagai mobil. Dikarenakan kualitas video yang kurang bagus. Kemungkinan system dapat mengira bahwa objek tersebut adalah mobil yang terparkir atau objek yang menyerupai mobil. Hasil yang didapatkan adalah 171 mobil.</span></p>
<h3><a name="bookmark34"></a><span class="font2"><a name="bookmark35"></a>Kendaraan Lewat : 22</span></h3><img src="https://jurnal.harianregional.com/media/92838-8.jpg" alt="" style="width:284pt;height:120pt;">
<p><span class="font1" style="font-weight:bold;">Figure 8. </span><span class="font1">Video Haar Cascade Classification</span></p>
<h3><a name="bookmark36"></a><span class="font2"><a name="bookmark37"></a>Kendaraan Lewat : 171</span></h3><img src="https://jurnal.harianregional.com/media/92838-9.jpg" alt="" style="width:280pt;height:122pt;">
<p><span class="font1" style="font-weight:bold;">Figure 9. </span><span class="font1">Hasil Haar Cascade Classification</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark38"></a><span class="font1" style="font-weight:bold;"><a name="bookmark39"></a>3.3. &nbsp;&nbsp;&nbsp;Single Shot Detector</span></h4></li></ul>
<p><span class="font1">Pada metode ini diperlukannya MobileNetSSD untuk mendeteksi beberapa objek. Penulis disini hanya menggunakan klasifikasi objek terhadap mobil. System akan mendeteksi mobil jika mobil yang ada dalam sebuah video memliki ciri-ciri yang sama didalam model MobileNetSSD. Dalam mendeteksi mobil sama seperti metode sebelumnya. Jika objek yang dideteksi adalah mobil maka mobil akan dikelilingi box berwarna hijau dan ditengah-tengah box berwarna hijau itu terdapat titik merah dapat dilihat di gambar no. 10. Dalam penghitungan objek mobil juga sama seperti penghitungan metode sebelumnya jika titik merah tersebut melewati garis biru maka mobil akan terhitung ke dalam system. Namun kekurangan dari metode ini kurangnya bisa mendeteksi jika objek berada jauh dari kamera. 1 Objek mobil juga dapat terhitung 2 kali atau lebih. Sehingga hasil yang dihasilkan lebih dari video originalnya dapat dilihat di gambar 11. Hasil yang didapatkan adalah 320 mobil.</span></p>
<h3><a name="bookmark40"></a><span class="font2"><a name="bookmark41"></a>Kendaraan Lewat : 242</span></h3><img src="https://jurnal.harianregional.com/media/92838-10.jpg" alt="" style="width:278pt;height:121pt;">
<p><span class="font1" style="font-weight:bold;">Figure 10. </span><span class="font1">Video Single Shot Detetctor</span></p>
<h3><a name="bookmark42"></a><span class="font2"><a name="bookmark43"></a>Kendaraan Lewat : 320</span></h3><img src="https://jurnal.harianregional.com/media/92838-11.jpg" alt="" style="width:281pt;height:121pt;">
<p><span class="font1" style="font-weight:bold;">Figure 11. </span><span class="font1">Hasil Single Shot Detetctor</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark44"></a><span class="font1" style="font-weight:bold;"><a name="bookmark45"></a>3.4. &nbsp;&nbsp;&nbsp;Video Original</span></h4></li></ul>
<p><span class="font1">Dalam video original penulis menghitung manual mobil yang terdapat di dalam 1 menit video tersebut. Hasil yang didapat dari menghitung mobil dengan manual adalah 158 mobil.</span></p>
<p><span class="font1">Bisa dilihat di gambar no. 12.</span></p><img src="https://jurnal.harianregional.com/media/92838-12.jpg" alt="" style="width:311pt;height:156pt;">
<p><span class="font1" style="font-weight:bold;">Figure 12. </span><span class="font1">Video Original</span></p>
<ul style="list-style:none;"><li>
<h4><a name="bookmark46"></a><span class="font1" style="font-weight:bold;"><a name="bookmark47"></a>4. &nbsp;&nbsp;&nbsp;Result</span></h4></li></ul>
<p><span class="font1">Berdasarkan penelitian yang dilakukan yaitu menghitung banyak mobil yang berlalu-lintas dengan menggunakan 3 metode yaitu metode Background Substraction, metode Haar Cascade Classification, dan SSD. Pengujian menggunakan input video yang dilakukan disetiap metodenya. Namun disetiap metode menghasilkan hasil yang berbeda-beda. Metode Background Substraction mendapat nilai prediksi yang jauh lebih tinggi dari video originalnya yaitu 205,69%. Banyak objek yang terhitung 2 kali atau lebih menyebabkan hasilnya jauh melewati nilai prediksi yang diharapkan. Metode Haar Cascade Classification mendapat nilai prediksi 108,22%. Metode ini sangat banyak mendeteksi sebagai objek mobil yang seharusnya itu bukan objek mobil ini dikarenakan kualitas video yang kurang bagus. Metode SSD mendapatkan nilai prediksi yang hampir sama dengan metode Background Substraction yaitu 202,53%. Karena menggunakan model dari MobileNet-SSD, 1 mobil yang terkena cahaya saat jalan dan saat melewati garis untuk menghitung ke system tidak terkena cahaya. Mobil dapat terhitung 2 kali atau lebih. Menurut hasil yang didapatkan penulis menyimpulkan bahwa metode Haar Cascade Classification lebih efisien dan akurat dibandingkan metode Background Subtraction dan metode Single Shot Detector (SSD) dalam menghitung mobil yang berlalu-lintas.</span></p>
<h4><a name="bookmark48"></a><span class="font1" style="font-weight:bold;"><a name="bookmark49"></a>References</span></h4>
<ul style="list-style:none;"><li>
<p><span class="font1">[1] &nbsp;&nbsp;&nbsp;I. Corporation, “OpenCV”, 2000. [Online]. Available :</span><a href="https://opencv.org/about/"><span class="font1"> </span><span class="font1" style="text-decoration:underline;">https://opencv.org/about/</span></a></p></li>
<li>
<p><span class="font1">[2] &nbsp;&nbsp;&nbsp;Alvin. Lazaro, Joko. Lianto. Buliali and Bilqis. Amaliah, “Deteksi Jenis Kendaraan di Jalan Menggunakan OpenCV” Jurnal Teknik ITS, vol. 6, no. 2, p. A293, 2017.</span></p></li>
<li>
<p><span class="font1">[3] &nbsp;&nbsp;&nbsp;Srimulia, “Mengenal OpenCV Dalam Python: Pengertian, Sejarah, Dukungan pada OS, Fitur-fitur”, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;August &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2022. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Online]. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Available:</span></p></li></ul>
<p><a href="https://idmetafora.com/news/read/1177/Mengenal-OpenCV-Dalam-Python-Pengertian-Sejarah-Dukungan-pada-OS-Fitur-fitur.html"><span class="font1" style="text-decoration:underline;">https://idmetafora.com/news/read/1177/Mengenal-OpenCV-Dalam-Python-Pengertian-</span></a><span class="font1" style="text-decoration:underline;"></span><a href="https://idmetafora.com/news/read/1177/Mengenal-OpenCV-Dalam-Python-Pengertian-Sejarah-Dukungan-pada-OS-Fitur-fitur.html"><span class="font1" style="text-decoration:underline;">Sejarah-Dukungan-pada-OS-Fitur-fitur.html</span></a></p>
<ul style="list-style:none;"><li>
<p><span class="font1">[4] &nbsp;&nbsp;&nbsp;Karina. Kaloh, Vecky. C. Poekoel, Muhamad. Dwisnanto. Putro, “Perbandingan Algoritma </span><span class="font1" style="font-style:italic;">Background Subtraction</span><span class="font1"> dan </span><span class="font1" style="font-style:italic;">Optical Flow</span><span class="font1"> Untuk Deteksi Manusia” E-Journal Teknik Informatika, vol. 13, no. 1, p. 2, 2018.</span></p></li>
<li>
<p><span class="font1">[5] &nbsp;&nbsp;&nbsp;Achmad. Solichin, Agus. Harjoko. “Metode </span><span class="font1" style="font-style:italic;">Background Subtraction</span><span class="font1"> untuk Deteksi Obyek Pejalan Kaki pada Lingkungan Statis” in Seminar Nasional Aplikasi Teknologi Informasi (SNATI), Yogyakarta, 2013, pp. B-3.</span></p></li>
<li>
<p><span class="font1">[6] &nbsp;&nbsp;&nbsp;Tria. Nugrahini, “Perbandingan Metode </span><span class="font1" style="font-style:italic;">Kalman Filter</span><span class="font1"> dan Metode </span><span class="font1" style="font-style:italic;">Ensemble Kalman Filter </span><span class="font1">Dalam Mendeteksi Gangguan Konduksi Panas Pada Batang Logam”, Universitas Jember, 2012.</span></p></li>
<li>
<p><span class="font1">[7] &nbsp;&nbsp;&nbsp;Deny. Nugroho. Triwibowo, Ema. Utami, Sukoco, “Analisis </span><span class="font1" style="font-style:italic;">Blob Detection</span><span class="font1"> Pada Pendeteksian dan Perhitungan Kendaraan di Jalan Tol” Jurnal Teknologi Informasi dan Komunikasi, vol. 10, no. 1, p. 3, 2020.</span></p></li>
<li>
<p><span class="font1">[8] &nbsp;&nbsp;&nbsp;Muhammad. Syarif, Wijanarto., “Deteksi Kedipan Mata dengan Haar Cascade Classifier dan Contour untuk Password Login Sistem” </span><span class="font1" style="font-style:italic;">Techno COM,</span><span class="font1"> vol. 14, no. 4, p. 244-246, 2015</span></p></li>
<li>
<p><span class="font1">[9] &nbsp;&nbsp;&nbsp;RD. Kusumanto, Wahyu. S. Pambudi, Alan. N. Tompunnu, “Aplikasi Sensor Visison untuk Deteksi MultiFace dan Menghitung Jumlah Orang” in Seminar Nasional Teknologi Informasi &amp;&nbsp;Komunikasi Terapan 2012 (Semantik 2012), Universitas Internasional Batam, 2012.</span></p></li>
<li>
<p><span class="font1">[10] &nbsp;&nbsp;&nbsp;Liu. Wei, Dragomir. Angueloy, Dumitru. Erhan, “SSD: Single Shot Multibox Detector” in </span><span class="font1" style="font-style:italic;">European Conference on Computer Vision,</span><span class="font1"> Springer, 2016 pp. 2-3.</span></p></li>
<li>
<p><span class="font1">[11] &nbsp;&nbsp;&nbsp;Yosia. Pradeska. Admaja, “ Sistem Penghitung Jumlah Pengunjung di Restoran Menggunakan Kamera Berbasis </span><span class="font1" style="font-style:italic;">Single Shot Detector</span><span class="font1"> (SSD)”, Universitas Dinamika, 2021.</span></p></li></ul>
<p><span class="font8">450</span></p>