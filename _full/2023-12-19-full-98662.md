---
layout: full_article
title: "Analisis Komputasi Paralel pada Image Encoding Framework untuk Konversi Citra Data Deret Waktu Sistem Kontrol Industri"
author: "Helmy Rahadian, Muhammad Rizalul Wahid, Zaenal Arifin"
categories: jte
canonical_url: https://jurnal.harianregional.com/jte/full-98662 
citation_abstract_html_url: "https://jurnal.harianregional.com/jte/id-98662"
citation_pdf_url: "https://jurnal.harianregional.com/jte/full-98662"  
comments: true
---

<p><span class="font12" style="font-style:italic;">Majalah Ilmiah Teknologi Elektro, Vol.22, No.2, Juli-Desember 2023</span></p>
<p><span class="font12" style="font-style:italic;">DOI: </span><a href="https://doi.org/10.24843/MITE.2023.v22i02.P06"><span class="font12" style="font-style:italic;">https://doi.org/10.24843/MITE.2023.v22i02.P06</span></a><span class="font12"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;193</span></p><a name="caption1"></a>
<h1><a name="bookmark0"></a><span class="font15" style="font-weight:bold;"><a name="bookmark1"></a>Analisis Komputasi Paralel pada Image Encoding Framework untuk Konversi Citra Data Deret Waktu</span><br><br><span class="font15" style="font-weight:bold;"><a name="bookmark2"></a>Sistem Kontrol Industri</span></h1>
<p><span class="font13">Helmy Rahadian<sup>1</sup>, Muhammad Rizalul Wahid<sup>2</sup>, Zaenal Arifin<sup>3</sup></span></p>
<p><span class="font11" style="font-style:italic;">[Submission: 27-02-2023, Accepted: 25-05-2023]</span></p>
<p><span class="font11" style="font-weight:bold;font-style:italic;">Abstract</span><span class="font11" style="font-weight:bold;">— Sensors in industrial control systems send a series of data each time, known as time series data, to the controller. The data contains important information for the controller to determine the control signal for the actuator. The appearance of anomalies in time series data can be detected using the Convolutional Neural Network (CNN) method utilizing image encoding techniques such as Gramian Angular Field (GAF) and Markov Transition Field (MTF). This technique converts time series data into images through data preparation, encoding, and conversion. Dividing extensive data into many smaller segments requires repeated encoding and conversion processes. Repeated processes that are done serially take a long time, which slows down the detection of anomalies and the responses that must be taken. This research applies parallel computation with Joblib and Mpire libraries on the GAF and MTF image encoding provided by the Python-based pyts library. The n_jobs configuration determines the number of CPU logical cores used to execute the program. According to the number of CPU logic cores of the computer, applying the value of n_jobs = 8 can save an average processing time of 63% (Joblib) and 49% (Mpire), which theoretically will be able to detect anomalies that occur at least every 62.73 ms (Joblib) and 86.20 ms (Mpire) compared to 167.51 ms in serial computing.</span></p>
<p><span class="font11" style="font-weight:bold;font-style:italic;">Keywords</span><span class="font11" style="font-weight:bold;">— Time series data, Anomaly, Encoding, Conversion, Image, Parallel, Python.</span></p>
<p><span class="font11" style="font-weight:bold;font-style:italic;">Intisari</span><span class="font11" style="font-weight:bold;">— Sensor pada sistem kontrol industri mengirimkan serangkaian data tiap waktu dikenal dengan data deret waktu ke kontroler. Data memiliki informasi penting bagi kontroler untuk menentukan sinyal kontrol bagi aktuator. Munculnya anomali pada data deret waktu dapat dideteksi dengan metode Convolutional Neural Network (CNN) memanfaatkan teknik image encoding seperti Gramian Angular Field (GAF) dan Markov Transition Field (MTF). Teknik ini mengubah data deret waktu menjadi citra melalui serangkaian tahap mulai persiapan data, encoding data, dan konversi citra. Pembagian data berukuran besar menjadi sejumlah segmen yang lebih kecil membutuhkan proses encoding dan konversi yang berulang. Proses berulang yang dikerjakan secara serial membutuhkan</span></p>
<p><span class="font11" style="font-weight:bold;">waktu yang lama sehingga memperlambat deteksi anomali dan tanggapan yang harus dilakukan. Penelitian ini menerapkan komputasi paralel dengan Joblib dan Mpire pada image encoding GAF dan MTF yang disediakan oleh pustaka pyts berbasis Python. Konfigurasi n_jobs menentukan jumlah inti logika CPU yang digunakan untuk mengeksekusi program. Penerapan nilai n_jobs = 8 yang disesuaikan dengan jumlah inti logika CPU komputer penelitian menghasilkan penghematan waktu proses rata-rata sebesar 63% (Joblib) dan 49% (Mpire) yang secara teoritis akan mampu mendeteksi anomali yang muncul minimal tiap 62.73 ms (Joblib) dan 86.20 ms (Mpire) dibandingkan dengan komputasi serial yakni setiap 167.51 ms.</span></p>
<p><span class="font11" style="font-weight:bold;font-style:italic;">Kata Kunci</span><span class="font11" style="font-weight:bold;">— Data deret waktu, Anomali, Encoding, Konversi, Citra, Paralel, Python.</span></p>
<ul style="list-style:none;"><li>
<h3><a name="bookmark3"></a><span class="font12"><a name="bookmark4"></a>I.</span><span class="font12" style="font-variant:small-caps;"> &nbsp;&nbsp;&nbsp;pendahuluan</span></h3></li></ul>
<p><span class="font12">Sistem kontrol industri (</span><span class="font12" style="font-style:italic;">Industrial Control System</span><span class="font12"> atau ICS) terdiri atas berbagai perangkat yang membentuk sebuah sistem terintegrasi yang bertujuan untuk mengontrol proses secara otomatis dan mempertahankan kestabilan. Sensor pada ICS secara kontinyu mengirimkan data kepada kontroler (seperti </span><span class="font12" style="font-style:italic;">Programmable Logic Controller</span><span class="font12"> atau PLC). Data ini merupakan hasil pengukuran sensor pada suatu proses tertentu dengan laju pencuplikan yang seragam dalam periode waktu tertentu dan dikenal sebagai </span><span class="font12" style="font-style:italic;">time series data</span><span class="font12"> atau data deret waktu. Analisis terhadap data deret waktu dilakukan untuk menemukan pola atau karakteristik data serta memprediksi nilai yang akan datang berdasarkan hasil pengamatan pada data sebelumnya untuk menjadi dasar pengambilan keputusan [1].</span></p>
<p><span class="font12">Sebagai hasil dari pengamatan kondisi suatu proses, sering kali data deret waktu menunjukkan anomali yaitu munculnya data yang menyimpang dari pola atau perilaku yang dikehendaki. Istilah anomali juga dikenal sebagai </span><span class="font12" style="font-style:italic;">outliers</span><span class="font12">, didefinisikan sebagai hasil pengamatan yang menyimpang jauh dari hasil pengamatan yang lain sehingga seolah-olah data tersebut dihasilkan oleh mekanisme pengamatan yang berbeda [2]. Tanggapan atas munculnya anomali bisa berupa pembersihan data maupun analisis lanjut [3]. Pembersihan data dilakukan jika anomali berasal dari </span><span class="font12" style="font-style:italic;">noise</span><span class="font12"> atau kesalahan perangkat maupun jalur komunikasi dan analisis lanjut dilakukan pada sebuah fenomena yang tidak biasa namun unik seperti pada kasus kecurangan finansial [4].</span></p>
<p><span class="font12">Metode atau teknik untuk mendeteksi anomali pada data deret waktu terdiri atas teknik berbasis pembelajaran mesin (</span><span class="font12" style="font-style:italic;">machine learning</span><span class="font12">/ML) dan berbasis statistik [5]. Beberapa tahun terakhir deteksi anomali berbasis ML telah banyak diadaptasi oleh banyak peneliti untuk diterapkan di berbagai</span></p>
<p><span class="font12">p-ISSN:1693 – 2951; e-ISSN: </span><span class="font3">2503-2372</span></p>
<div><img src="https://jurnal.harianregional.com/media/98662-1.png" alt="" style="width:59pt;height:37pt;">
<p><span class="font2">9 772503 2371 BO</span></p>
</div><br clear="all">
<p><span class="font12">bidang. Selanjutnya ML bertransformasi menjadi pembelajaran mendalam (</span><span class="font12" style="font-style:italic;">deep learning</span><span class="font12">/DL) yang memiliki kapabilitas tinggi dalam pemrosesan dan pembelajaran data dengan kompleksitas tinggi termasuk </span><span class="font12" style="font-style:italic;">high dimensional data</span><span class="font12">, data temporal dan spasial. Sejumlah algoritma DL telah terbukti memiliki performa lebih baik dibandingkan metode konvensional seperti metode statistik dalam mengatasi persoalan di berbagai aplikasi nyata [6].</span></p>
<p><span class="font12" style="font-style:italic;">Convolutional neural network</span><span class="font12"> (CNN) adalah salah satu metode DL yang banyak dipakai untuk mendeteksi anomali. Metode ini terinspirasi oleh cara kerja bagian otak yang disebut </span><span class="font12" style="font-style:italic;">visual cortex</span><span class="font12"> dalam menanggapi rangsangan visual. CNN memproses masukan berupa citra dan melalui serangkaian proses yang terjadi pada beberapa lapisan (berisi neuronneuron) hingga diperoleh karakteristik atau ciri utama pada citra tersebut. Data </span><span class="font12" style="font-style:italic;">time series</span><span class="font12"> pada ICS terlebih dahulu diubah menjadi citra menggunakan teknik </span><span class="font12" style="font-style:italic;">image encoding</span><span class="font12"> seperti Gramian Angular Field (GAF) dan Markov Transition Field (MTF). Citra hasil </span><span class="font12" style="font-style:italic;">image encoding</span><span class="font12"> tersebut kemudian menjadi masukan bagi CNN yang akan menentukan ada tidaknya anomali pada citra.</span></p>
<p><span class="font12">Penelitian yang mengombinasikan </span><span class="font12" style="font-style:italic;">image encoding</span><span class="font12"> dan CNN sudah banyak dilakukan diantaranya: mendeteksi anomali pada trafik komunikasi OPC [7]; mendeteksi anomali pada penggunaan daya listrik [8]; deteksi anomali pada belitan mesin pencelupan (</span><span class="font12" style="font-style:italic;">dyeing machine</span><span class="font12">) [9]; deteksi anomali pada </span><span class="font12" style="font-style:italic;">structural health monitoring</span><span class="font12"> (SHM) [10]; dan deteksi kondisi jantung melalui data ECG pada aplikasi e-Health [11].</span></p>
<p><span class="font12">Pustaka pyts berbasis Python menyediakan </span><span class="font12" style="font-style:italic;">framework image encoding</span><span class="font12"> baik GAF, MTF dan Recurrent plot (RP) untuk mengubah data deret waktu menjadi citra [12]. Pustaka ini memiliki dua tahap: (a) tahap mengubah data deret waktu menjadi matriks sesuai jenis </span><span class="font12" style="font-style:italic;">image encoding</span><span class="font12">; dan (b) tahap mengubah matriks menjadi citra. Beberapa pustaka lain digunakan untuk keperluan tahapan tersebut seperti contohnya penggunaan pustaka matplotlib untuk menghasilkan citra. Data deret waktu yang berukuran besar akan dibagi menjadi segmen-segmen berukuran sama. Proses konversi dari data deret waktu menjadi citra dilakukan secara satu-persatu atau serial. Hal ini membutuhkan waktu relatif lama dan semakin lama jika jumlah segmen semakin banyak. Lamanya proses konversi mempengaruhi jeda waktu antara sejak munculnya anomali hingga anomali tersebut berhasil dideteksi. Sehingga dimungkinkan tanggapan atas anomali terlambat dilakukan dan dapat mengakibatkan kerugian.</span></p>
<p><span class="font12">Penelitian ini bermaksud untuk menerapkan konsep komputasi paralel untuk mempercepat waktu </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra. Kecepatan eksekusi program bisa ditingkatkan dengan memanfaatkan seluruh inti CPU yang dimiliki komputer. Hal ini diharapkan dapat memangkas waktu proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra sehingga memperkecil selisih waktu antara munculnya anomali hingga berhasil dideteksi dan tanggapan atas anomali bisa segera diambil untuk menghindari potensi kerugian.</span></p>
<p><a name="bookmark5"></a><span class="font12">Makalah ini disusun mengikuti struktur berikut: Bagian II menjelaskan mengenai data deret waktu dan deteksi anomali, </span><span class="font12" style="font-style:italic;">image encoding</span><span class="font12"> GAF dan MTF serta konsep pemrograman</span></p>
<p><span class="font12">paralel. Selanjutnya pada Bagian III ditunjukkan mengenai metodologi penelitian yang dilakukan. Hasil penelitian dan pembahasannya dijabarkan pada Bagian IV dan ditutup dengan kesimpulan dan saran pada Bagian V.</span></p>
<ul style="list-style:none;"><li>
<h3><a name="bookmark6"></a><span class="font12"><a name="bookmark7"></a>II.</span><span class="font12" style="font-variant:small-caps;"> &nbsp;&nbsp;&nbsp;Tinjauan Pustaka</span></h3></li></ul>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">A. &nbsp;&nbsp;&nbsp;Data deret waktu dan deteksi anomali</span></p></li></ul>
<p><span class="font12">Data deret waktu diperoleh dari pengamatan atau pengukuran dalam kurun waktu atau periode tertentu. Data deret waktu banyak dijumpai di berbagai bidang seperti finansial, industri maupun kesehatan. Data deret waktu termasuk dalam data temporal yang memiliki karakteristik seperti jumlah data relatif besar, berdimensi tinggi (memiliki banyak variabel) dan diperbarui secara kontinu [13].</span></p>
<p><span class="font12">Analisis data deret waktu dilakukan untuk menemukan informasi yang terkandung di dalamnya. Berdasarkan informasi yang diperoleh dari data, maka dapat dilakukan: </span><span class="font12" style="font-style:italic;">forecasting</span><span class="font12"> atau prediksi – yakni memperkirakan nilai yang akan muncul berdasarkan pola dari data-data sebelumnya; </span><span class="font12" style="font-style:italic;">clustering</span><span class="font12"> – mengelompokkan data yang tanpa label menggunakan pendekatan </span><span class="font12" style="font-style:italic;">unsupervised learning</span><span class="font12"> seperti jenis iklim yang berbeda dapat dikelompokkan atau ditentukan berdasarkan data temperatur; </span><span class="font12" style="font-style:italic;">classification</span><span class="font12"> – bertujuan menghasilkan </span><span class="font12" style="font-style:italic;">classifier</span><span class="font12"> yang secara otomatis mengelompokkan jenis data baru yang memiliki label dengan pendekatan </span><span class="font12" style="font-style:italic;">supervised learning</span><span class="font12">, seperti menentukan jantung dalam kondisi normal atau abnormal melalui pengamatan data sensor ECG [14].</span></p>
<p><span class="font12">Anomali dapat muncul pada data deret waktu dan menyimpan informasi tertentu yang berbeda dengan perilaku proses yang dikehendaki. Anomali memiliki beberapa jenis diantaranya: (1) </span><span class="font12" style="font-style:italic;">point anomaly</span><span class="font12"> – anomali tunggal (individual) yang berbeda dari data yang lain; (2) </span><span class="font12" style="font-style:italic;">collective anomaly</span><span class="font12"> – sekumpulan data yang tiap individu datanya masih termasuk data yang dapat ditoleransi (tidak berbeda) namun secara keseluruhan berbeda dari data yang lain; (3) </span><span class="font12" style="font-style:italic;">contextual anomaly</span><span class="font12"> – data individu atau kelompok data yang masih termasuk dalam toleransi namun ketidakteraturan bila</span></p>
<p><span class="font12">dibandingkan data di sekelilingnya [15]. Ilustrasi ketiga jenis</span></p><img src="https://jurnal.harianregional.com/media/98662-2.jpg" alt="" style="width:244pt;height:88pt;"><img src="https://jurnal.harianregional.com/media/98662-3.jpg" alt="" style="width:113pt;height:71pt;">
<p><span class="font10">Gambar 1: Jenis-jenis anomali (a) </span><span class="font10" style="font-style:italic;">point anomaly</span><span class="font10">; (b) </span><span class="font10" style="font-style:italic;">collective anomaly</span><span class="font10">; (c) </span><span class="font10" style="font-style:italic;">contextual anomaly</span></p>
<p><span class="font12" style="font-style:italic;">DOI: </span><a href="https://doi.org/10.24843/MITE.2023.v22i02.P06"><span class="font12" style="font-style:italic;">https://doi.org/10.24843/MITE.2023.v22i02.P06</span></a></p>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">B. &nbsp;&nbsp;&nbsp;Open Platform Communication</span></p></li></ul>
<p><span class="font12" style="font-style:italic;">Open Platform Communication</span><span class="font12"> (OPC) merupakan antarmuka komunikasi antar perangkat pada sektor industri dan dikenal juga dengan nama lain ysitu </span><span class="font12" style="font-style:italic;">open process control</span><span class="font12">. OPC menjadi jawaban atas semakin beragamnya jenis dan kompleksitas perangkat otomasi industri yang menyebabkan rendahnya interoperabilitas antar perangkat yang dapat menyebabkan kenaikan biaya perawatan, pengembangan, resiko keamanan dan dapat pula menurunkan resiliensi sistem [16]. Sejak tahun 1996, OPC digunakan sebagai protokol komunikasi standar yang memberikan jaminan keandalan dan keamanan dalam pertukaran data antar perangkat otomasi dalam industri. OPC generasi awal ini sering disebut dengan OPC </span><span class="font12" style="font-style:italic;">classic</span><span class="font12">. Pada tahun 2006, OPC UA (</span><span class="font12" style="font-style:italic;">unified architecture</span><span class="font12">) dirilis menggantikan OPC </span><span class="font12" style="font-style:italic;">classic</span><span class="font12"> dan telah ditetapkan menjadi stadard internasional oleh </span><span class="font12" style="font-style:italic;">International Electrotechnical Commission</span><span class="font12"> (IEC) yang dikenal sebagai IEC62541.</span></p>
<p><span class="font12">Komunikasi pada OPC UA mengadopsi model </span><span class="font12" style="font-style:italic;">client-server </span><span class="font12">dan </span><span class="font12" style="font-style:italic;">publish-subscribe</span><span class="font12">. Model </span><span class="font12" style="font-style:italic;">client-server</span><span class="font12"> merupakan model komunikasi yang paling banyak dijumpai di industri. Model ini digunakan apabila diperlukan komunikasi asinkron dengan jumlah data yang besar. Komunikasi diinisiasi oleh OPC </span><span class="font12" style="font-style:italic;">client </span><span class="font12">untuk memperoleh data tertentu yang dimiliki oleh OPC </span><span class="font12" style="font-style:italic;">server</span><span class="font12">. OPC </span><span class="font12" style="font-style:italic;">client</span><span class="font12"> umumnya berupa komputer yang menjalankan program seperti HMI dan SCADA sedangkan OPC </span><span class="font12" style="font-style:italic;">server</span><span class="font12"> bisa berupa perangkat kecil seperti sensor dan PLC [17]. Selain itu sebuah komputer dapat diprogram untuk berperan baik sebagai OPC </span><span class="font12" style="font-style:italic;">client</span><span class="font12"> maupun </span><span class="font12" style="font-style:italic;">server</span><span class="font12">.</span></p>
<p><span class="font12">Saat ini tersedia berbagai program atau perangkat lunak untuk mengimplementasikan protokol komunikasi OPC UA. Terdapat pilihan perangkat lunak </span><span class="font12" style="font-style:italic;">propietary</span><span class="font12"> (berbayar atau bersifat komersial) dan </span><span class="font12" style="font-style:italic;">open source</span><span class="font12"> (bisa digunakan atau dikembangkan tanpa biaya). Program OPC UA </span><span class="font12" style="font-style:italic;">propietary </span><span class="font12">banyak digunakan karena memiliki keunggulan dibandingkan dengan program </span><span class="font12" style="font-style:italic;">open source</span><span class="font12"> dalam hal dukungan teknis dan kestabilan. Selain itu, kebanyakan pengguna tidak memiliki keahlian dalam melakukan konfigurasi yang dibutuhkan oleh program </span><span class="font12" style="font-style:italic;">open source</span><span class="font12">. Penggunaan program OPC UA </span><span class="font12" style="font-style:italic;">open source</span><span class="font12"> bisa menjadi pilihan lebih baik apabila biaya menjadi pertimbangan utama. Beberapa program OPC UA </span><span class="font12" style="font-style:italic;">open source </span><span class="font12">diantaranya: open62541 (berbasis bahasa pemrograman C), UA-.NETStandard (C#), node-opcua (Java), python-opcua dan opcua-asyncio (python). Menurut [18], hanya open62541 dan UA-.NETStandard yang cocok untuk implementasi yang membutuhkan banyak </span><span class="font12" style="font-style:italic;">client</span><span class="font12"> dan </span><span class="font12" style="font-style:italic;">server</span><span class="font12"> (atau </span><span class="font12" style="font-style:italic;">node</span><span class="font12">).</span></p>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">C. &nbsp;&nbsp;&nbsp;Image encoding (GAF dan MTF)</span></p></li></ul>
<p><span class="font12">Kombinasi </span><span class="font12" style="font-style:italic;">image encoding</span><span class="font12"> dan CNN saat ini banyak digunakan dalam berbagai aplikasi dan riset serta menunjukkan performa yang baik. </span><span class="font12" style="font-style:italic;">Framework image encoding</span><span class="font12"> Gramian Angular Field (GAF) dan Markov Transition Field (MTF) banyak digunakan untuk mengkonversi data deret waktu menjadi citra serta menunjukkan performa yang baik dalam klasifikasi dan perbaikan data pada citra [19].</span></p>
<p><span class="font12">Helmy Rahadian: Analisis Komputasi Paralel pada …</span></p>
<p><span class="font12">GAF memiliki dua variasi yaitu </span><span class="font12" style="font-style:italic;">gramian angular difference field</span><span class="font12"> (GADF) dan </span><span class="font12" style="font-style:italic;">gramian angular summation field</span><span class="font12"> (GASF). GAF merepresentasikan data deret waktu yang biasa dalam koordinat kartesian menjadi koordinat polar. Perbedaan GASF dan GADF terletak pada operasi pada matriks </span><span class="font12" style="font-style:italic;">gramian</span><span class="font12">: pengurangan (GADF, dari kata </span><span class="font12" style="font-style:italic;">difference</span><span class="font12">) dan penambahan (GASF, dari kata </span><span class="font12" style="font-style:italic;">summation</span><span class="font12">). Tahapan proses mengubah data deret waktu X = (x</span><span class="font9">1</span><span class="font12">, x</span><span class="font9">2</span><span class="font12">, …, x</span><span class="font9">n</span><span class="font12">) menjadi matriks gramian [19]:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font13">•</span><span class="font12"> &nbsp;&nbsp;&nbsp;Normalisasi x</span><span class="font9">i </span><span class="font12">pada rentang [-1, &nbsp;1] atau [0, &nbsp;1]</span></p></li></ul>
<p><span class="font12">menggunakan (1).</span></p>
<ul style="list-style:none;"><li>
<p><span class="font13">•</span><span class="font12"> &nbsp;&nbsp;&nbsp;Mengubah nilai deret waktu ke koordinat polar, melalui (2).</span></p></li>
<li>
<p><span class="font13">•</span><span class="font12"> &nbsp;&nbsp;&nbsp;Membentuk matriks </span><span class="font12" style="font-style:italic;">gramian</span><span class="font12"> GADF (3) atau GASF (4).</span></p>
<div>
<p><span class="font12"><sup>x</sup></span><span class="font9">-ι</span></p>
</div><br clear="all"></li></ul>
<p><span class="font12" style="font-style:italic;">(x<sub>l</sub> — max(Χ))</span><span class="font12"> + </span><span class="font12" style="font-style:italic;">(x<sub>l</sub> — min(Χ)) max(Χ) — min(Χ)</span></p>
<div>
<p><span class="font12" style="font-style:italic;">or X</span><span class="font8" style="font-style:italic;">o</span></p>
</div><br clear="all">
<p><span class="font12" style="font-style:italic;">x<sub>l</sub> — min(Χ) max(Χ) — min(Χ)</span></p>
<div>
<p><span class="font12">{</span></p>
</div><br clear="all">
<p><span class="font12">0 </span><span class="font12" style="font-style:italic;">= arccos(x</span><span class="font8" style="font-style:italic;">i</span><span class="font12" style="font-style:italic;">), — 1 ≤ x<sub>t</sub> ≤ 1,x<sub>t</sub> </span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">Χ F</span></p>
<h2><a name="bookmark8"></a><span class="font12"><sup><a name="bookmark9"></a>r</sup> = jf⅛</span><span class="font7">∈</span><span class="font12">&quot;</span></h2>
<p><span class="font12" style="font-style:italic;">G ADF(i,j) = sin[(0</span><span class="font8" style="font-style:italic;">ι </span><span class="font12" style="font-style:italic;">— 0 ^]</span></p>
<div>
<p><span class="font12" style="font-style:italic;">GADF =</span></p>
</div><br clear="all">
<div>
<p><span class="font12" style="font-style:italic;">'sin[(0<sub>1</sub> —</span><span class="font12"> 0</span><span class="font9">1</span><span class="font12">)]</span></p>
<p><span class="font12">.sin[(0</span><span class="font9">ι </span><span class="font12" style="font-style:italic;">— 0<sub>n</sub>)}</span></p>
</div><br clear="all">
<p><span class="font12" style="font-style:italic;">sin[(0<sub>n</sub> —</span><span class="font12"> 0)]'</span></p>
<p><span class="font12" style="font-style:italic;">sin[(0</span><span class="font8" style="font-style:italic;">n </span><span class="font12" style="font-style:italic;">— 0<sub>n</sub>)]-</span></p>
<p><span class="font12" style="font-style:italic;">GASF(i,j) = cos[(0<sub>i</sub> + 0</span><span class="font8" style="font-style:italic;">j</span><span class="font12" style="font-style:italic;">)]</span></p>
<div>
<p><span class="font12" style="font-style:italic;">GASF =</span></p>
</div><br clear="all">
<div>
<p><span class="font12" style="font-style:italic;">'cos[(0<sub>1</sub> +</span><span class="font12"> 0</span><span class="font9">1</span><span class="font12">)]</span></p>
<p><span class="font12">.COS[(0</span><span class="font9">ι </span><span class="font12">+ 0</span><span class="font9">n</span><span class="font12">)]</span></p>
</div><br clear="all">
<p><span class="font12" style="font-style:italic;">cos[(0<sub>n</sub> + 0<sub>1</sub>)]'</span></p>
<p><span class="font12" style="font-style:italic;">Cθs[(0</span><span class="font8" style="font-style:italic;">n </span><span class="font12" style="font-style:italic;">+ 0n)</span><span class="font8" style="font-style:italic;">].</span></p>
<div>
<p><span class="font12">(1)</span></p>
</div><br clear="all">
<div>
<p><span class="font12">(2)</span></p>
</div><br clear="all">
<div>
<p><span class="font12">(3)</span></p>
</div><br clear="all">
<div>
<p><span class="font12">(4)</span></p>
</div><br clear="all">
<p><span class="font12">MTF pada dasarnya melakukan </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> terhadap transisi dinamis secara statistik pada data deret waktu dengan penambahan probabilitas transisi Markov secara sekuensial untuk mempertahankan informasi di dalam domain waktu. Jika diketahui data deret waktu X = (x</span><span class="font9">1</span><span class="font12">, x</span><span class="font9">2</span><span class="font12">, …, x</span><span class="font9">n</span><span class="font12">), maka tahapan </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> adalah [20]:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font13">•</span><span class="font12"> &nbsp;&nbsp;&nbsp;Membagi data deret waktu dengan nilai quantile Q tertentu kemudian setiap x</span><span class="font9">i </span><span class="font12">dipetakan pada quantile yang sesuai (q</span><span class="font9">j </span><span class="font12">dengan </span><span class="font12" style="font-style:italic;">j</span><span class="font12"> </span><span class="font7">∈</span><span class="font12"> </span><span class="font12" style="font-style:italic;">[1,Q])</span><span class="font12"> sehingga diperoleh matriks probabilitas transisi W berdimensi Q x Q (5); dengan w</span><span class="font9">ij </span><span class="font12">adalah probabilitas data x yang saat ini berada pada q</span><span class="font9">i</span><span class="font12">akan berpindah ke q</span><span class="font9">j </span><span class="font12">di waktu mendatang (6).</span></p></li>
<li>
<p><span class="font13">•</span><span class="font12"> &nbsp;&nbsp;&nbsp;Mengembangkan matriks W yang tiap elemennya saling independen menjadi matriks Markov transition field (M) melalui (7).</span></p></li></ul>
<p><span class="font12">p-ISSN:1693 – 2951; e-ISSN: </span><span class="font3">2503-2372</span></p><img src="https://jurnal.harianregional.com/media/98662-4.png" alt="" style="width:82pt;height:55pt;">
<div>
<table border="1">
<tr><td style="vertical-align:bottom;">
<p><span class="font12" style="font-style:italic;">W =</span></p></td><td style="vertical-align:top;">
<p><span class="font9">■ <sup>w</sup>11</span></p>
<p><span class="font12" style="font-style:italic;">W</span><span class="font8" style="font-style:italic;">21</span></p></td><td style="vertical-align:top;">
<p><span class="font6" style="font-style:italic;"><sup>w</sup></span><span class="font8" style="font-style:italic;">12</span></p>
<p><span class="font12" style="font-style:italic;">w</span><span class="font8" style="font-style:italic;">22</span></p></td><td style="vertical-align:top;">
<p><span class="font8" style="font-style:italic;">■. &nbsp;&nbsp;&nbsp;w^-</span></p>
<p><span class="font8" style="font-style:italic;">■. &nbsp;&nbsp;&nbsp;</span><span class="font12" style="font-style:italic;">w</span><span class="font8" style="font-style:italic;">2Q</span></p></td></tr>
<tr><td style="vertical-align:top;"></td><td style="vertical-align:bottom;">
<p><span class="font8" style="font-style:italic;">. <sup>w</sup>Q1</span></p></td><td style="vertical-align:bottom;">
<p><span class="font6" style="font-style:italic;"><sup>w</sup></span><span class="font8" style="font-style:italic;">Q2</span></p></td><td style="vertical-align:bottom;">
<p><span class="font6" style="font-style:italic;">■. &nbsp;&nbsp;&nbsp;&nbsp;<sup>w</sup></span><span class="font8" style="font-style:italic;">QQ.</span></p></td></tr>
</table>
</div><br clear="all">
<p><span class="font12" style="font-style:italic;">w<sub>ij</sub> = p{x<sub>t</sub></span><span class="font12"> </span><span class="font7">∈</span><span class="font12"> </span><span class="font12" style="font-style:italic;">q<sub>i</sub></span><span class="font12"> | </span><span class="font12" style="font-style:italic;">X</span><span class="font8" style="font-style:italic;">t-1</span><span class="font12"> </span><span class="font7">∈</span><span class="font12"> </span><span class="font12" style="font-style:italic;">q<sub>j</sub>}</span><span class="font11"> d</span><span class="font12">engan </span><span class="font12" style="font-style:italic;">∑<sub>j</sub></span><span class="font8" style="font-style:italic;">=</span><span class="font12" style="font-style:italic;"><sub>1</sub>w<sub>ij</sub> =</span><span class="font12"> 1 </span><span class="font9" style="font-style:italic;">■ wij</span><span class="font7" style="font-style:italic;">∖</span><span class="font12" style="font-style:italic;"> X</span><span class="font9" style="font-style:italic;">1</span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;"><sub>i</sub></span><span class="font12" style="font-style:italic;">,X</span><span class="font9" style="font-style:italic;">1</span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;">j &nbsp;■■■ &nbsp;</span><span class="font12" style="font-style:italic;">w</span><span class="font9" style="font-style:italic;"><sub>lj</sub></span><span class="font7" style="font-style:italic;">∖</span><span class="font12" style="font-style:italic;"> X</span><span class="font9" style="font-style:italic;">ι</span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;"><sub>i</sub></span><span class="font12" style="font-style:italic;">,x</span><span class="font9" style="font-style:italic;"><sub>n</sub></span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q<sub>j</sub>-</span></p>
<p><span class="font12" style="font-style:italic;"><sub>M=</sub> W</span><span class="font9" style="font-style:italic;">i<sub>j</sub></span><span class="font7" style="font-style:italic;">∖</span><span class="font12" style="font-style:italic;"> x</span><span class="font9" style="font-style:italic;"><sub>2</sub></span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;">i</span><span class="font12" style="font-style:italic;">,X</span><span class="font9" style="font-style:italic;">ι</span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q<sub>j</sub> &nbsp;... &nbsp;W</span><span class="font9" style="font-style:italic;">i<sub>j</sub></span><span class="font7" style="font-style:italic;">∖</span><span class="font12" style="font-style:italic;"> x</span><span class="font9" style="font-style:italic;"><sub>2</sub></span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;">i</span><span class="font12" style="font-style:italic;">,x</span><span class="font9" style="font-style:italic;"><sub>n</sub></span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;"><sub>j</sub></span></p>
<p><span class="font12" style="font-style:italic;">W<sub>i</sub>j</span><span class="font7" style="font-style:italic;">∖</span><span class="font12" style="font-style:italic;"> X</span><span class="font9" style="font-style:italic;">n</span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;">i</span><span class="font12" style="font-style:italic;">,X</span><span class="font9" style="font-style:italic;">ι</span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;">j</span><span class="font12"> &nbsp;■ &nbsp;</span><span class="font12" style="font-style:italic;">W</span><span class="font9" style="font-style:italic;">ij</span><span class="font7" style="font-style:italic;">∖</span><span class="font12" style="font-style:italic;"> X</span><span class="font9" style="font-style:italic;">n</span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;">i</span><span class="font12" style="font-style:italic;">,X</span><span class="font9" style="font-style:italic;">n</span><span class="font7" style="font-style:italic;">∈</span><span class="font12" style="font-style:italic;">q</span><span class="font9" style="font-style:italic;">j</span><span class="font12" style="font-style:italic;">.</span></p>
<div>
<p><span class="font12">(5)</span></p>
<p><span class="font12">(6)</span></p>
<p><span class="font12">(7)</span></p>
</div><br clear="all">
<p><span class="font12" style="font-style:italic;">Encoding</span><span class="font12"> dengan MTF memiliki parameter “</span><span class="font12" style="font-style:italic;">strategy</span><span class="font12">” dan “n_bins” yang menentukan cara dan jumlah pembagian data deret waktu yang akan diproses. Terdapat tiga pilihan parameter “</span><span class="font12" style="font-style:italic;">strategy</span><span class="font12">” pada MTF yaitu:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font13">•</span><span class="font12"> &nbsp;&nbsp;&nbsp;Uniform – membagi data deret waktu menjadi sejumlah n_bins bagian dengan tiap bagian memiliki rentang yang sama.</span></p></li>
<li>
<p><span class="font13">•</span><span class="font12"> &nbsp;&nbsp;&nbsp;Quantile – membagi data deret waktu menjadi sejumlah n_bins bagian dengan tiap bagian memiliki jumlah data yang sama</span></p></li>
<li>
<p><span class="font13">•</span><span class="font12"> &nbsp;&nbsp;&nbsp;Normal – data deret waktu dibagi dengan sejumlah n_bins yang mengikuti kuantil dari distribusi normal</span></p></li></ul>
<p><span class="font12">Matriks yang dihasilkan oleh </span><span class="font12" style="font-style:italic;">image encoding</span><span class="font12"> selanjutnya dikonversi menjadi citra. Pustaka pyts menggunakan pustaka lain yaitu matplotlib untuk mengkonversi matriks menjadi citra. Tahapan </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi data deret waktu menjadi citra yang disediakan oleh pustaka pyts dijabarkan dalam algoritma 1 dan algoritma 2.</span></p>
<p><span class="font11" style="font-weight:bold;">Algoritma 1 </span><span class="font11">GAF</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">1 &nbsp;&nbsp;&nbsp;function GAF(mode)</span></p></li>
<li>
<p><span class="font11">2 &nbsp;dt = time series data</span></p></li>
<li>
<p><span class="font11">3 &nbsp;For i in range(num_of_segment)</span></p></li>
<li>
<p><span class="font11">4 &nbsp;&nbsp;&nbsp;&nbsp;X = dt[i]</span></p></li>
<li>
<p><span class="font11">5 &nbsp;&nbsp;&nbsp;Enc[i] = GAF(X)</span></p></li>
<li>
<p><span class="font11">6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Img[i] = fig.enc[i]</span></p></li>
<li>
<p><span class="font11">7 &nbsp;&nbsp;&nbsp;end function</span></p></li></ul>
<p><span class="font11" style="font-weight:bold;">Algoritma 2 </span><span class="font11">MTF</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">1 &nbsp;&nbsp;&nbsp;function MTF(strategi, bin)</span></p></li>
<li>
<p><span class="font11">2 &nbsp;&nbsp;&nbsp;dt = time series data</span></p></li>
<li>
<p><span class="font11">3 &nbsp;&nbsp;&nbsp;For i in range(num_of_segment)</span></p></li>
<li>
<p><span class="font11">4 &nbsp;&nbsp;&nbsp;&nbsp;X = dt[i]</span></p></li>
<li>
<p><span class="font11">5 &nbsp;&nbsp;&nbsp;Enc[i] = MTF(X)</span></p></li>
<li>
<p><span class="font11">6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Img[i] = fig.enc[i]</span></p></li>
<li>
<p><span class="font11">7 &nbsp;&nbsp;&nbsp;end function</span></p></li></ul>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">D. Komputasi paralel</span></p></li></ul>
<p><span class="font12">Algoritma komputasi berkembang menjadi semakin kompleks seiring dengan banyaknya permasalahan yang harus diselesaikan. Perangkat keras seperti komputer saat ini terus dikembangkan untuk dapat mendukung proses komputasi tersebut. Spesifikasi perangkat komputasi yang dapat mempengaruhi kecepatan eksekusi program diantaranya jumlah inti (</span><span class="font12" style="font-style:italic;">core</span><span class="font12">), frekuensi </span><span class="font12" style="font-style:italic;">clock central processing unit </span><span class="font12">(CPU), kecepatan memori dan </span><span class="font12" style="font-style:italic;">hard disk</span><span class="font12"> serta dalam konteks</span></p>
<p><span class="font12">aplikasi tertentu termasuk kapasitas atau </span><span class="font12" style="font-style:italic;">bandwith</span><span class="font12"> jaringan komputer.</span></p>
<p><span class="font12">Python adalah salah satu bahasa pemrograman yang saat ini populer digunakan untuk komputasi saintifik seperti pengolahan citra serta beragam </span><span class="font12" style="font-style:italic;">problem solving</span><span class="font12"> berbasis pembelajaran mesin dan pembelajaran mendalam seperti pada [21] serta untuk membangun sistem kontrol seperti kontrol robotika pada [22]. Hal ini didukung karena Python merupakan bahasa pemrograman tingkat tinggi yang mudah dipahami, </span><span class="font12" style="font-style:italic;">open source</span><span class="font12"> (tidak membutuhkan biaya lisensi), memiliki dukungan pustaka yang sangat lengkap dan portabilitasnya yang baik karena bisa dijalankan di berbagai platform perangkat keras maupun perangkat lunak (sistem operasi komputer).</span></p>
<p><span class="font12">Semakin besar jumlah dan kompleksitas data maka peranan komputasi paralel menjadi semakin penting. Python adalah salah satu bahasa pemrograman yang mendukung komputasi secara paralel. Hal ini berarti, program Python bisa dijalankan secara bersamaan pada beberapa inti prosesor (CPU) atau beberapa CPU dengan memanfaatkan siklus CPU yang tidak terpakai ketika ada program yang menunggu sumber daya eksternal. Hal ini akan menjadikan </span><span class="font12" style="font-style:italic;">running time</span><span class="font12"> program yang dikerjakan secara paralel lebih cepat dari pada dikerjakan secara serial [23]. Ilustrasi eksekusi program secara paralel dan serial ditunjukkan oleh</span><a href="#bookmark10"><span class="font12"> Gambar 2.</span></a></p><img src="https://jurnal.harianregional.com/media/98662-5.jpg" alt="" style="width:173pt;height:186pt;">
<p><span class="font1" style="font-weight:bold;">ParjIeI computing &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial computing</span></p>
<p><a name="bookmark10"></a><span class="font10">Gambar 2: Komputasi paralel dan serial, berdasarkan [23]</span></p>
<p><span class="font12">Penerapan komputasi paralel pada Python dilakukan melalui dua pendekatan yaitu melalui multi-proses dan multi-threading. Sebuah proses merujuk pada sebuah program komputer. Setiap program Python adalah sebuah proses dan memiliki sebuah </span><span class="font12" style="font-style:italic;">thread</span><span class="font12"> default disebut dengan main thread yang digunakan untuk mengeksekusi instruksi pada program [24]. Contoh sebuah proses adalah program </span><span class="font12" style="font-style:italic;">intepreter</span><span class="font12"> Python yang mengeksekusi kode instruksi Python pada level </span><span class="font12" style="font-style:italic;">byte-code </span><span class="font12">seperti Jupyter Notebook. Sedangkan </span><span class="font12" style="font-style:italic;">thread</span><span class="font12"> adalah urutan eksekusi pada sebuah program komputer. Setiap program adalah sebuah proses dan memiliki setidaknya satu thread yang mengeksekusi instruksi untuk proses tersebut. </span><span class="font12" style="font-style:italic;">Thread </span><span class="font12">menentukan urutan atau cara kode instruksi dieksekusi.</span></p>
<p><a name="bookmark11"></a><span class="font12">Joblib dan Mpire adalah contoh pustaka Python yang bisa digunakan untuk menjalankan komputasi paralel dan menambah kecepatan komputasi. Joblib mendukung multiproses dan multi-</span><span class="font12" style="font-style:italic;">thread</span><span class="font12"> serta memiliki fitur </span><span class="font12" style="font-style:italic;">transparent disk cache</span><span class="font12"> untuk menyimpan obyek Python yang dihasilkan oleh proses atau </span><span class="font12" style="font-style:italic;">thread</span><span class="font12">. </span><span class="font12" style="font-style:italic;">Cache</span><span class="font12"> ini tidak hanya membatu menghindari pekerjaan berulang namun bisa digunakan kembali untuk proses yang tertunda atau setelah mengalami crash [25]. Sedangkan Mpire adalah pustaka yang dikembangkan berdasarkan pustaka </span><span class="font12" style="font-style:italic;">multiprocessing</span><span class="font12"> yang merupakan pustaka standar Python [26]. Joblib [27] dan Mpire [28] bersifat </span><span class="font12" style="font-style:italic;">open source</span><span class="font12"> dan dapat diakses dan di-</span><span class="font12" style="font-style:italic;">install </span><span class="font12">Github.</span></p>
<ul style="list-style:none;"><li>
<h3><a name="bookmark12"></a><span class="font12"><a name="bookmark13"></a>III.</span><span class="font12" style="font-variant:small-caps;"> &nbsp;&nbsp;&nbsp;Metodologi</span></h3></li></ul>
<p><span class="font12">Penelitian ini dilakukan melalui beberapa tahapan yaitu:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font12">1. &nbsp;&nbsp;&nbsp;Akuisisi data</span></p></li>
<li>
<p><span class="font12">2.</span><span class="font12" style="font-style:italic;"> &nbsp;&nbsp;&nbsp;Encoding</span><span class="font12"> data menggunakan GAF dan MTF dengan pencatatan waktu:</span></p></li></ul>
<ul style="list-style:none;"><li>
<p><span class="font5">- &nbsp;</span><span class="font12">Pemrosesan secara serial</span></p></li>
<li>
<p><span class="font5">- &nbsp;</span><span class="font12">Pemrosesan secara paralel</span></p></li></ul>
<ul style="list-style:none;"><li>
<p><span class="font12">3. &nbsp;&nbsp;&nbsp;Analisis performa </span><span class="font12" style="font-style:italic;">encoding</span></p></li></ul>
<p><span class="font12">Perangkat lunak yang digunakan dalam penelitian ini adalah:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font12">1. &nbsp;&nbsp;&nbsp;Platform Anaconda 2.3.3 dengan Python 3.9.15 dan Jupyter Lab 3.5.3</span></p></li>
<li>
<p><span class="font12">2. &nbsp;Pustakan pyts versi 0.12.0</span></p></li>
<li>
<p><span class="font12">3. &nbsp;Pustaka opcua-asyncio library v1.0.0</span></p></li>
<li>
<p><span class="font12">4. &nbsp;Pustaka Joblib versi 1.2.0</span></p></li>
<li>
<p><span class="font12">5. &nbsp;Pustaka Mpire versi 2.6.0</span></p></li>
<li>
<p><span class="font12">6. &nbsp;Windows 11 Pro 64-bit OS</span></p></li></ul>
<p><span class="font12">Sedangkan perangkat keras yang digunakan dalam penelitian ini adalah komputer laptop dengan spesifikasi perangkat keras:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font12">1. &nbsp;&nbsp;&nbsp;CPU Intel i7-8650u @1.90 GHz dengan 8 buah </span><span class="font12" style="font-style:italic;">logical processors</span></p></li>
<li>
<p><span class="font12">2. &nbsp;&nbsp;&nbsp;RAM 16 GB 2400 MHz</span></p></li>
<li>
<p><span class="font12">3. &nbsp;&nbsp;&nbsp;SSD 1 TB nvme PCIe 1.3</span></p></li>
<li>
<p><span class="font12">4. &nbsp;&nbsp;&nbsp;Komputer dijalankan dengan sumber daya AC PLN (mode </span><span class="font12" style="font-style:italic;">performance</span><span class="font12">)</span></p></li></ul>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">A. &nbsp;&nbsp;&nbsp;Akuisisi data</span></p></li></ul>
<p><span class="font12">Data penelitian diperoleh dari pembacaan arus mini fan DC oleh Raspberry Pi 3B melalui sensor INA219 menggunakan protokol I<sup>2</sup>C. Nilai arus dibaca secara kontinyu dengan periode 200ms hingga terkumpul 45.000 data. Raspberry bertindak sebagai sebuah OPC </span><span class="font12" style="font-style:italic;">client</span><span class="font12"> yang mengirimkan data arus yang baru menuju ke laptop sebagai OCP </span><span class="font12" style="font-style:italic;">server</span><span class="font12">. OPC </span><span class="font12" style="font-style:italic;">client</span><span class="font12"> dan </span><span class="font12" style="font-style:italic;">server</span><span class="font12"> dihubungkan melalui jaringan komputer lokal menggunakan pustaka komunikasi opcua-asyncio v1.0.0. Sistem akuisisi data ini meniru arsitektur OPC </span><span class="font12" style="font-style:italic;">client</span><span class="font12">-</span><span class="font12" style="font-style:italic;">server </span><span class="font12">pada ICS. Diagram blok sistem akuisisi data ditunjukkan oleh </span><a href="#bookmark11"><span class="font12">Gambar 3.</span></a></p>
<p><span class="font12">Helmy Rahadian: Analisis Komputasi Paralel pada …</span></p><img src="https://jurnal.harianregional.com/media/98662-6.jpg" alt="" style="width:251pt;height:106pt;">
<p><span class="font10">Gambar 3: Diagram blok sistem akuisisi data</span></p>
<p><span class="font12">Proses selanjutnya yang dilakukan setelah memperoleh data adalah </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra. Proses ini mengikuti diagram alir yang ditunjukkan oleh</span><a href="#bookmark14"><span class="font12"> Gambar 4.</span></a></p><img src="https://jurnal.harianregional.com/media/98662-7.jpg" alt="" style="width:200pt;height:288pt;">
<p><a name="bookmark14"></a><span class="font10">Gambar 4: Diagram alir proses </span><span class="font10" style="font-style:italic;">encoding</span><span class="font10"> dan konversi citra</span></p>
<p><span class="font12">Sensor INA219 membaca nilai arus listrik yang mensuplai DC fan dalam kondisi normal. Periode pembacaan data sebesar 200ms dengan total data yang diambil sebanyak 45000 data. Data ini dibagi menjadi 2250 segmen dengan tiap segmennya terdiri atas 20 data. Selanjutnya tiap segmen di-</span><span class="font12" style="font-style:italic;">encoding </span><span class="font12">dengan GAF dan MTF menghasilkan 2250 matriks berdimensi 20x20. Selain itu, pada tiap segmen disisipkan data anomali berupa arus bernilai antara nol hingga 1mA menggantikan data normal. Data anomali disebar di tiap segmen pada posisi dan jumlah yang acak (antara 1 hingga 10 data anomali per segmen).</span></p>
<p><span class="font12">Setelah dihasilkan total 4500 matriks berisi </span><span class="font12" style="font-style:italic;">encoded value </span><span class="font12">(2250 segmen normal dan 2250 segmen anomali) maka p-ISSN:1693 – 2951; e-ISSN: </span><span class="font3">2503-2372</span></p>
<div><img src="https://jurnal.harianregional.com/media/98662-8.png" alt="" style="width:71pt;height:44pt;">
</div><br clear="all">
<p><span class="font12">selanjutnya dilakukan konversi matriks tersebut menjadi citra. Hasil akhir yang diperoleh adalah 2250 citra normal dan 2250 citra anomali. Sehingga jumlah iterasi atau perulangan eksekusi program yang dilakukan adalah masing-masing 2250 untuk proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra normal dan anomali.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">B. &nbsp;&nbsp;&nbsp;Encoding dan konversi citra</span></p></li></ul>
<p><span class="font12">Penelitian ini melakukan </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> GAF dengan metode “</span><span class="font12" style="font-style:italic;">difference</span><span class="font12">” (GADF) dengan asumsi </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> GASF memiliki kemiripan dengan GADF hanya berbeda pada operasi pengurangan dan penambahan sehingga beban komputasi dianggap sama. Sedangkan </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> MTF menggunakan “</span><span class="font12" style="font-style:italic;">strategy</span><span class="font12">”: uniform, quantile, dan normal dengan jumlah bin </span><span class="font12" style="font-style:italic;">default</span><span class="font12"> yaitu 5. Parameter GADF dan MTF yang lain, seperti “image_size”, “sample_range”, “</span><span class="font12" style="font-style:italic;">overlapping</span><span class="font12">”, dan “</span><span class="font12" style="font-style:italic;">flatten</span><span class="font12">” tetap bernilai </span><span class="font12" style="font-style:italic;">default</span><span class="font12">.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">C. &nbsp;&nbsp;&nbsp;Pustaka komputasi paralel</span></p></li></ul>
<p><a name="bookmark15"></a><span class="font12">Penelitian ini memanfaatkan dua buah pustaka untuk melakukan komputasi secara paralel pada proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra yaitu Joblib dan Mpire. Konfigurasi pustaka joblib dan mpire difokuskan pada parameter n_jobs yang menentukan jumlah inti pada CPU yang akan digunakan untuk menjalankan proses. Pada penelitian ini, proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra akan dijalankan menggunakan parameter n_jobs = 2, 4, dan 8 (menyesuaikan jumlah maksimal inti logika CPU yang dimiliki perangkat komputasi). Setiap proses dilakukan pencatatan waktu untuk kemudian dilakukan analisis performa komputasi paralel serta peningkatan kecepatan yang diperoleh bila dibandingkan dengan proses yang dikerjakan secara serial.</span></p>
<p><span class="font12" style="font-style:italic;">Encoding</span><span class="font12"> GAF dan MTF dengan pustaka pyts pada dasarnya memiliki struktur kode program yang sama. Selain melakukan </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> juga melakukan konversi citra. Algoritma 1 dan algoritma 2 menggambarkan proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> data deret waktu dan konversi citra yang masih dikerjakan secara serial sedangkan algoritma 3 menunjukkan proses tersebut namun dekerjakan secara paralel dengan Pustaka Joblib dan Mpire. Algoritma 3 menggambarkan secara spesifik proses </span><span class="font12" style="font-style:italic;">encoding </span><span class="font12">dan konversi citra menggunakan </span><span class="font12" style="font-style:italic;">framework</span><span class="font12"> MTF namun algoritma ini juga berlaku untuk </span><span class="font12" style="font-style:italic;">framework</span><span class="font12"> GADF dengan mengganti fungsi MTF dengan fungsi GADF.</span></p>
<p><span class="font11" style="font-weight:bold;">Algoritma 3 </span><span class="font11">MTF Paralel</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">1 &nbsp;&nbsp;&nbsp;dt = time series data</span></p></li>
<li>
<p><span class="font11">2 &nbsp;&nbsp;&nbsp;function MTF(mode, bin)</span></p></li>
<li>
<p><span class="font11">3 &nbsp;&nbsp;&nbsp;&nbsp;X = dt[i]</span></p></li>
<li>
<p><span class="font11">4 &nbsp;&nbsp;&nbsp;Enc[i] = MTF(X)</span></p></li>
<li>
<p><span class="font11">5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Img[i] = fig.enc[i]</span></p></li>
<li>
<p><span class="font11">6 &nbsp;&nbsp;&nbsp;end function</span></p></li></ul>
<p><span class="font11">7</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">8 &nbsp;</span><span class="font11" style="font-weight:bold;"># Joblib</span></p></li>
<li>
<p><span class="font11">9 &nbsp;&nbsp;&nbsp;with Parallel(n_jobs = nCPU) as parallel:</span></p></li>
<li>
<p><span class="font11">10 &nbsp;&nbsp;&nbsp;parallel([delayed(MTF)(i) for i in range(n_seg)]))</span></p></li></ul>
<p><span class="font11">11</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">12</span><span class="font11" style="font-weight:bold;"> &nbsp;&nbsp;&nbsp;# Mpire</span></p></li>
<li>
<p><span class="font11">13 &nbsp;&nbsp;&nbsp;with WorkerPool(n_jobs = nCPU, shared_objects = dt) as pool:</span></p></li>
<li>
<p><span class="font11">14 &nbsp;&nbsp;&nbsp;pool.map(MTF, range(2250))</span></p></li></ul>
<ul style="list-style:none;"><li>
<h3><a name="bookmark16"></a><span class="font12"><a name="bookmark17"></a>IV. </span><span class="font12" style="font-variant:small-caps;">Hasil dan Pembahasan</span></h3></li></ul>
<p><span class="font12">Bab ini berisi hasil penelitian berupa catatan waktu proses eksekusi program </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra menggunakan </span><span class="font12" style="font-style:italic;">framework</span><span class="font12"> GADF dan MTF yang dikerjakan secara seri dan paralel menggunakan pustaka Joblib dan Mpire dengan variasi nilai n_jobs. Selanjutnya dilakukan analisis terhadap data penelitian untuk mengetahui performa komputasi paralel bila diterapkan pada sistem deteksi anomali.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">A. &nbsp;&nbsp;&nbsp;Citra hasil proses encoding dan konversi data deret waktu</span></p></li></ul>
<p><span class="font12">Contoh citra hasil proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi diambil dari data deret waktu segmen pertama. Data arus listrik normal dan anomali pada segmen ini ditunjukkan oleh</span><a href="#bookmark15"><span class="font12"> Gambar 5.</span></a></p><img src="https://jurnal.harianregional.com/media/98662-9.jpg" alt="" style="width:191pt;height:113pt;">
<p><span class="font0" style="font-weight:bold;">• Normal</span></p>
<p><span class="font0" style="font-weight:bold;">-∙~ Anomali</span></p>
<p><span class="font10">Gambar 5: Data deret waktu segmen pertama</span></p>
<p><span class="font12">Segmen pertama mengalami anomali pada data ke 7, 8, dan 9 dengan arus listrik yang tiba-tiba menjadi sangat kecil (hampir nol). Data normal dan anomali pada segmen pertama ini kemudian melewati proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi menggunakan GADF, MTF uniform 5 (nilai bin = 5), MTF quantile 5, dan MTF normal 5 menghasilkan pasangan citra normal dan anomali. Sebagai contoh, citra GADF dan MTF uniform 5 ditunjukkan oleh</span><a href="#bookmark18"><span class="font12"> Gambar 6 </span></a><span class="font12">dan</span><a href="#bookmark19"><span class="font12"> Gambar 7. </span></a><span class="font12">Rata-rata setiap citra berukuran 4 KB.</span></p><img src="https://jurnal.harianregional.com/media/98662-10.jpg" alt="" style="width:227pt;height:93pt;">
<p><a name="bookmark18"></a><span class="font10">Gambar 6: Citra hasil konversi data deret waktu dengan GADF pada segmen 1 – kondisi normal (kiri) dan anomali (kanan)</span></p><img src="https://jurnal.harianregional.com/media/98662-11.jpg" alt="" style="width:227pt;height:96pt;">
<p><a name="bookmark19"></a><span class="font10">Gambar 7: Citra hasil konversi data deret waktu dengan MTF uniform 5 pada segmen 1 – kondisi normal (kiri) dan anomali (kanan)</span></p>
<p><span class="font12">Secara keseluruhan, dari pasangan 2250 segmen data deret waktu normal dan anomali akan menghasilkan 4500 pasang citra yang akan menjadi masukan pada proses selanjutnya yaitu klasifikasi citra CNN (tidak termasuk dalam fokus penelitian ini). Selanjutnya setelah terbukti menghasilkan citra normal dan anomali, dilakukan proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi sebanyak 2250 kali secara serial dan paralel.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">B. &nbsp;&nbsp;&nbsp;Serial</span></p></li></ul>
<p><a name="bookmark20"></a><span class="font12">Proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra dengan GADF dan MTF uniform 5, MTF quantile 5, dan MTF normal 5 secara serial menghasilkan catatan waktu yang ditunjukkan oleh</span><a href="#bookmark20"><span class="font12"> Tabel 1.</span></a></p>
<h3><a name="bookmark21"></a><span class="font12" style="font-variant:small-caps;"><a name="bookmark22"></a>Tabel</span><span class="font10"> 1</span></h3>
<h3><a name="bookmark23"></a><span class="font12" style="font-variant:small-caps;"><a name="bookmark24"></a>Waktu </span><span class="font10" style="font-style:italic;">E</span><span class="font9" style="font-style:italic;">NCODING</span><span class="font10"> &amp;&nbsp;</span><span class="font12" style="font-variant:small-caps;">Konversi Citra</span><span class="font10"> GADF </span><span class="font12" style="font-variant:small-caps;">Secara Serial</span></h3>
<div><img src="https://jurnal.harianregional.com/media/98662-12.jpg" alt="" style="width:248pt;height:145pt;">
<p><a name="bookmark25"></a><span class="font10">Gambar 8: Waktu proses </span><span class="font10" style="font-style:italic;">encoding</span><span class="font10"> dan konversi serial</span></p>
</div><br clear="all">
<table border="1">
<tr><td rowspan="2" style="vertical-align:middle;">
<p><span class="font11">Percobaan</span></p></td><td rowspan="2" style="vertical-align:bottom;">
<p><span class="font11">GADF (waktu, s)</span></p></td><td colspan="3" style="vertical-align:bottom;">
<p><span class="font11">MTF (waktu, s)</span></p></td></tr>
<tr><td style="vertical-align:bottom;">
<p><span class="font11">Uniform 5</span></p></td><td style="vertical-align:bottom;">
<p><span class="font11">Quantile 5</span></p></td><td style="vertical-align:bottom;">
<p><span class="font11">Normal 5</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">1</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">323.36</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">330.18</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">327.07</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">317</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">2</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">345.37</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">334.31</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">352.61</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">339.85</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">3</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">339.51</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">335.28</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">336.74</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">328.79</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">4</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">336.47</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">353.48</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">358.21</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">340.39</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">5</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">361.1</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">367.16</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">366.48</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">365.79</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">6</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">338.12</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">394.38</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">369.36</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">354.87</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">7</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">346.74</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">394.97</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">393.93</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">369.16</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">8</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">364.45</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">416.03</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">404.99</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">389.19</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">9</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">385.6</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">464</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">444.97</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">420.05</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">10</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">444.19</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">547.07</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">508.81</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">465.94</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">Rerata</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">358.491</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">393.686</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">386.317</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">369.103</span></p></td></tr>
</table>
<p><a name="bookmark26"></a><span class="font12">Catatan waktu 10 kali percobaan </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> GADF dan MTF secara serial menunjukkan peningkatan khususnya setelah percobaan ke-7 seperti ditunjukkan pada</span><a href="#bookmark25"><span class="font12"> Gambar 8.</span></a><span class="font12"> Peningkatan waktu proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi disebabkan oleh memori (RAM) makin penuh. Penggunaan RAM di atas 90% terjadi pada percobaan ke-7 dan semakin bertambah pada percobaan terakhir. Hal ini kemungkinan terjadi karena citra yang dihasilkan pada percobaan sebelumnya tidak terhapus dan terakumulasi di memori. Komputer dapat mengalami kondisi </span><span class="font12" style="font-style:italic;">not responding</span><span class="font12"> karena sistem operasi kekurangan </span><span class="font12" style="font-style:italic;">resource </span><span class="font12">memori untuk menjalankan perintah lainnya. Selama percobaan menghasilkan 450 ribu citra dengan ukuran 4 kB/citra sehingga membutuhkan memori sebesar 1.8 GB.</span></p>
<p><a name="bookmark27"></a><span class="font12">Oleh karena itu, eksekusi program secara serial tidak bisa sekedar dengan mengulang-ulang eksekusi. Dalam penelitian ini, eksekusi program sebanyak 2250 kali tidak langsung memenuhi memori namun jika dilakukan lebih banyak (2250 x 10 percobaan) akan meningkatkan resiko memori penuh sehingga diperlukan tambahan berupa fungsi atau metode untuk menghapus citra yang sudah tidak dipakai di memori. Tidak seperti efek yang terjadi pada memori, penggunaan CPU pada pemrosesan serial tidak terlalu tinggi. Terlihat pada </span><span class="font12" style="font-style:italic;">Windows Resource Monitor</span><span class="font12"> (WRM) di</span><a href="#bookmark28"><span class="font12"> Gambar 9, </span></a><span class="font12">pada saat percobaan GADF ke-7, hanya ada satu proses Python yang aktif dengan utilisasi CPU sebesar 9% dengan rerata 7.45% dalam satu menit terakhir.</span></p><img src="https://jurnal.harianregional.com/media/98662-13.jpg" alt="" style="width:248pt;height:99pt;">
<p><a name="bookmark28"></a><span class="font10">Gambar 9: </span><span class="font10" style="font-style:italic;">Windows resource monitor</span><span class="font10"> (serial)</span></p>
<ul style="list-style:none;"><li>
<p><span class="font12" style="font-style:italic;">C. &nbsp;&nbsp;&nbsp;Paralel</span></p></li></ul>
<p><span class="font12">Waktu yang diperlukan untuk melakukan </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra GADF menggunakan pustaka Joblib dan Mpire dengan variasi parameter n_jobs sebesar 2, 4, dan 8 CPU ditunjukkan oleh</span><a href="#bookmark26"><span class="font12"> Tabel 2 </span></a><span class="font12">dan</span><a href="#bookmark27"><span class="font12"> Tabel 3.</span></a><span class="font12"> Nilai pada tabel adalah rerata dari sepuluh kali percobaan tiap metode </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12">.</span></p>
<h3><a name="bookmark29"></a><span class="font12" style="font-variant:small-caps;"><a name="bookmark30"></a>Tabel</span><span class="font10"> 2</span></h3>
<h3><a name="bookmark31"></a><span class="font12" style="font-variant:small-caps;"><a name="bookmark32"></a>Rerata Waktu Proses </span><span class="font10" style="font-style:italic;">E</span><span class="font9" style="font-style:italic;">NCODING</span><span class="font10"> &amp;&nbsp;</span><span class="font12" style="font-variant:small-caps;">Konversi Secara Paralel (Joblib)</span></h3>
<table border="1">
<tr><td rowspan="2" style="vertical-align:middle;">
<p><span class="font11" style="font-style:italic;">Encoding</span><span class="font11"> &amp;&nbsp;Konversi Citra</span></p></td><td colspan="3" style="vertical-align:bottom;">
<p><span class="font11">Joblib (waktu, s)</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">n_job</span></p>
<p><span class="font11">= 2 CPU</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">n_job</span></p>
<p><span class="font11">= 4 CPU</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">n_job</span></p>
<p><span class="font11">= 8 CPU</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">GADF</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">252.29</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">190.71</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">150.49</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">Uniform 5</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">253.40</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">173.51</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">140.89</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">Quantile 5</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">253.47</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">175.95</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">137.79</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">Normal 5</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">249.73</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">171.98</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">135.35</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">Rerata</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">252.22</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">178.04</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">141.13</span></p></td></tr>
</table>
<h3><a name="bookmark33"></a><span class="font12" style="font-variant:small-caps;"><a name="bookmark34"></a>Tabel</span><span class="font10"> 3</span></h3>
<h3><a name="bookmark35"></a><span class="font12" style="font-variant:small-caps;"><a name="bookmark36"></a>Rerata Waktu Proses </span><span class="font10" style="font-style:italic;">E</span><span class="font9" style="font-style:italic;">NCODING</span><span class="font10"> &amp;&nbsp;</span><span class="font12" style="font-variant:small-caps;">Konversi Secara Paralel (Mpire)</span></h3>
<div>
<p><span class="font12">Helmy Rahadian: Analisis Komputasi Paralel pada …</span></p>
</div><br clear="all">
<div>
<p><span class="font12">p-ISSN:1693 – 2951; e-ISSN: </span><span class="font3">2503-2372</span></p>
</div><br clear="all">
<div><img src="https://jurnal.harianregional.com/media/98662-14.png" alt="" style="width:82pt;height:55pt;">
</div><br clear="all">
<table border="1">
<tr><td rowspan="2" style="vertical-align:middle;">
<p><span class="font11" style="font-style:italic;">Encoding</span><span class="font11"> &amp;&nbsp;Konversi Citra</span></p></td><td colspan="3" style="vertical-align:bottom;">
<p><span class="font11">Mpire (waktu, s)</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">n_job</span></p>
<p><span class="font11">= 2 CPU</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">n_job</span></p>
<p><span class="font11">= 4 CPU</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">n_job</span></p>
<p><span class="font11">= 8 CPU</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">GADF</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">314.35</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">234.67</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">209.23</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">Uniform 5</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">314.70</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">220.65</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">188.64</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">Quantile 5</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">306.60</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">221.91</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">191.31</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">Normal 5</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">312.83</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">219.40</span></p></td><td style="vertical-align:middle;">
<p><span class="font11">186.64</span></p></td></tr>
<tr><td style="vertical-align:middle;">
<p><span class="font11">Rerata</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">312.12</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">224.16</span></p></td><td style="vertical-align:middle;">
<p><span class="font11" style="font-weight:bold;">193.95</span></p></td></tr>
</table>
<p><span class="font12">Berdasarkan</span><a href="#bookmark26"><span class="font12"> Tabel 2 </span></a><span class="font12">dan</span><a href="#bookmark27"><span class="font12"> Tabel 3,</span></a><span class="font12"> nilai n_jobs yang makin tinggi mempercepat waktu proses. Hal ini karena nilai n_jobs berpengaruh terhadap jumlah inti CPU yang bisa digunakan untuk mengeksekusi program. Nilai n_jobs = 1 berarti program hanya bisa dieksekusi secara bergantian (serial) pada satu inti CPU. Pada penelitian ini nilai maksimal n_jobs adalah 8 (sesuai dengan jumlah inti logika pada komputer) yang berarti eksekusi program bisa dilakukan secara paralel pada 8 inti CPU.</span></p>
<p><a name="bookmark37"></a><span class="font12">Sesuai pengamatan selama penelitian, saat n_jobs = 1. utilisasi CPU sekitar 36% kemudian saat n_jobs = 2 utilisasi CPU mencapai sekitar 90% dan meningkat menjadi 100% ketika n_jobs dinaikkan menjadi 4 dan 8. Pada saat n_jobs bernilai 1, setiap </span><span class="font12" style="font-style:italic;">task</span><span class="font12"> dikerjakan secara bergantian (serial) hanya pada satu inti CPU sehingga membutuhkan waktu eksekusi yang lama. Utilisasi CPU pada inti yang mengeksekusi program relatif tinggi namun secara keseluruhan utilisasi cukup rendah karena inti CPU yang lain tidak digunakan. Sedangkan ketika nilai n_jobs dinaikkan (lebih dari 1) maka program akan dieksekusi secara paralel. Interpreter Python akan mengalokasikan jumlah </span><span class="font12" style="font-style:italic;">task</span><span class="font12"> yang bisa dikerjakan secara independen ke inti CPU yang tersedia. Hal ini akan menyebabkan semua inti CPU bekerja mengeksekusi program (utilisasi CPU meningkat) sehingga waktu proses semakin cepat. Perbandingan utilisasi CPU antara eksekusi program secara serial (n_jobs = 1) dan paralel (n_jobs = 8) ditunjukkan melalui WRM pada</span><a href="#bookmark38"><span class="font12"> Gambar 10.</span></a></p><img src="https://jurnal.harianregional.com/media/98662-15.jpg" alt="" style="width:251pt;height:140pt;">
<p><a name="bookmark38"></a><span class="font10">Gambar 10: Perbandingan utilisasi CPU ketika mengeksekusi program (dengan pustaka Joblib) – secara serial (kiri) dan secara paralel (kanan)</span></p>
<p><span class="font12">Sementara itu, masih berdasarkan pengamatan melalui WRM, jumlah proses Python yang aktif ketika menggunakan Joblib mengikuti nilai n_jobs. Hal yang agak berbeda terjadi pada Mpire, jumlah proses Python yang aktif lebih banyak satu buah daripada nilai n_jobs dan jumlah </span><span class="font12" style="font-style:italic;">thread</span><span class="font12"> yang lebih banyak daripada Joblib. Meskipun demikian, berdasarkan Tabel 2 dan</span><a href="#bookmark27"><span class="font12"> Tabel 3,</span></a><span class="font12"> secara umum rerata waktu Joblib lebih cepat daripada Mpire. Grafik durasi proses waktu eksekusi program dengan variasi n_jobs ditunjukkan oleh</span><a href="#bookmark37"><span class="font12"> Gambar 11.</span></a></p>
<p><a href="#bookmark39"><span class="font12">Gambar 12 </span></a><span class="font12">menunjukkan persentase penghematan waktu proses yang diperoleh dengan eksekusi program secara paralel dengan n_jobs = 2, 4, dan 8 berturut-turut sebesar:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font13">• &nbsp;</span><span class="font12">33%, 53%, dan 63% menggunakan Joblib</span></p></li>
<li>
<p><span class="font13">• &nbsp;</span><span class="font12">17%, 41%, dan 49% menggunakan Mpire</span></p></li></ul><img src="https://jurnal.harianregional.com/media/98662-16.jpg" alt="" style="width:251pt;height:123pt;">
<p><span class="font10">Gambar 11: Perbandingan waktu proses rata-rata serial &amp;&nbsp;paralel (Joblib dan Mpire)</span></p>
<p><span class="font4" style="font-weight:bold;">Peningkatan Performa Proses Encoding &amp;&nbsp;Konversi Secara Paralel</span></p><img src="https://jurnal.harianregional.com/media/98662-17.jpg" alt="" style="width:191pt;height:106pt;">
<p><a name="bookmark39"></a><span class="font10">Gambar 12: Persentase peningkatan performa dengan komputasi secara paralel</span></p>
<p><span class="font12">Berdasarkan peningkatan performa yang diperoleh dengan mengunakan semua CPU (8 buah) maka proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi citra dengan Joblib membutuhkan waktu lebih cepat yakni 62.73 ms untuk menghasilkan sepasang citra (normal dan anomali) sedangkan Mpire membutuhkan 86.2 ms/pasang citra. Waktu pemrosesan secara paralel dengan dua pustaka jauh lebih cepat jika dibandingkan dengan proses serial yang membutuhkan 167.51 ms/pasang citra. Secara teoritis, terkait dengan deteksi anomali, maka penerapan komputasi paralel dengan Joblib dan Mpire mampu menangkap munculnya anomali pada data deret waktu yang terjadi minimal setiap 62.73 ms dan 86.2 ms.</span></p>
<h3><a name="bookmark40"></a><span class="font12"><a name="bookmark41"></a>V. </span><span class="font12" style="font-variant:small-caps;">Kesimpulan</span></h3>
<p><span class="font12">Proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi data deret waktu menggunakan beberapa </span><span class="font12" style="font-style:italic;">image encoding frameworks</span><span class="font12"> seperti GAF dan MTF banyak digunakan untuk berbagai keperluan termasuk deteksi anomali pada sistem kontrol industri. Pembagian data deret waktu yang berukuran besar menjadi segmen-segmen yang lebih kecil memerlukan proses </span><span class="font12" style="font-style:italic;">encoding </span><span class="font12">dan konversi berulang. Penelitian ini menerapkan komputasi paralel pada proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> dan konversi data deret waktu yang diperoleh dari sistem kontrol industri dengan tujuan memperoleh waktu proses yang lebih cepat daripada komputasi serial. Waktu proses yang lebih cepat berarti semakin cepat anomali bisa terdeteksi dan tindakan penanggulangan bisa dilakukan.</span></p>
<p><span class="font12">Joblib dan Mpire merupakan pustaka Python yang menyediakan kapabilitas eksekusi program secara paralel melalui pengaturan nilai parameter n_jobs yang akan</span></p>
<p><span class="font12" style="font-style:italic;">Majalah Ilmiah Teknologi Elektro, Vol.22, No.2, Juli-Desember DOI: </span><a href="https://doi.org/10.24843/MITE.2023.v22i02.P06"><span class="font12" style="font-style:italic;">https://doi.org/10.24843/MITE.2023.v22i02.P06</span></a><span class="font12" style="font-style:italic;"> </span><span class="font12">menentukan jumlah inti logika CPU yang dapat digunakan untuk mengeksekusi program. Hasil yang diperoleh dari sepuluh kali percobaan eksekusi proses </span><span class="font12" style="font-style:italic;">encoding</span><span class="font12"> data deret waktu dan konversi menjadi 4500 citra secara paralel dengan pustaka Joblib dan Mpire menunjukkan penghematan waktu proses yang diperoleh sebanding dengan kenaikan nilai parameter n_jobs.</span></p>
<p><span class="font12">Nilai n_jobs = 2, 4, dan 8 menghasilkan penghematan waktu proses rata-rata sebesar 33%, 53%, dan 63% (pada pustaka Joblib) dan sebesar 17%, 41%, dan 49% (pada pustaka Mpire) dibandingkan dengan eksekusi program secara serial. Semakin tinggi nilai n_jobs maka semakin banyak inti logika CPU yang bisa digunakan untuk memproses program secara paralel sehingga waktu proses yang diperlukan semakin cepat. Secara teoritis, penerapan komputasi paralel dengan Joblib dan Mpire dengan nilai n_jobs = 8 untuk deteksi anomaly akan mampu merekam munculnya anomali pada data deret waktu minimal setiap 62.73 ms dan 86.2 ms dibandingkan 167.51 ms pada komputasi serial.</span></p>
<h3><a name="bookmark42"></a><span class="font12" style="font-variant:small-caps;"><a name="bookmark43"></a>Referensi</span></h3>
<ul style="list-style:none;"><li>
<p><span class="font10">[1] &nbsp;&nbsp;&nbsp;Z. Liu, Z. Zhu, J. Gao, and C. Xu, “Forecast Methods for Time Series Data: A Survey,” </span><span class="font10" style="font-style:italic;">IEEE Access</span><span class="font10">, vol. 9, pp. 91896–91912, 2021, doi: 10.1109/ACCESS.2021.3091162.</span></p></li>
<li>
<p><span class="font10">[2] &nbsp;&nbsp;&nbsp;D. M. Hawkins, </span><span class="font10" style="font-style:italic;">Identification of Outliers</span><span class="font10">. Dordrecht: Springer Netherlands, 1980. doi: 10.1007/978-94-015-3994-4.</span></p></li>
<li>
<p><span class="font10">[3] &nbsp;&nbsp;&nbsp;A. Blázquez-García, A. Conde, U. Mori, and J. A. Lozano, “A Review on Outlier/Anomaly Detection in Time Series Data,” </span><span class="font10" style="font-style:italic;">ACM Comput. Surv.</span><span class="font10">, vol. 54, no. 3, pp. 1–33, Apr. 2022, doi: 10.1145/3444690.</span></p></li>
<li>
<p><span class="font10">[4] &nbsp;&nbsp;C. C. Aggarwal, </span><span class="font10" style="font-style:italic;">Outlier Analysis</span><span class="font10">. Cham: Springer International</span></p></li></ul>
<p><span class="font10">Publishing, 2017. doi: 10.1007/978-3-319-47578-3.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font10">[5] &nbsp;K. Shaukat </span><span class="font10" style="font-style:italic;">et al.</span><span class="font10">, “A Review of Time-Series Anomaly Detection</span></p></li></ul>
<p><span class="font10">Techniques: A Step to Future Perspectives,” in </span><span class="font10" style="font-style:italic;">Advances in Information and Communication</span><span class="font10">, K. Arai, Ed., in Advances in Intelligent Systems and Computing. Cham: Springer International Publishing, 2021, pp. 865– 877. doi: 10.1007/978-3-030-73100-7_60.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font10">[6] &nbsp;&nbsp;&nbsp;G. Pang, C. Shen, L. Cao, and A. V. D. Hengel, “Deep Learning for Anomaly Detection: A Review,” </span><span class="font10" style="font-style:italic;">ACM Comput. Surv.</span><span class="font10">, vol. 54, no. 2, pp. 1–38, Apr. 2021, doi: 10.1145/3439950.</span></p></li>
<li>
<p><span class="font10">[7] &nbsp;&nbsp;&nbsp;H. Rahadian, S. Bandong, A. Widyotriatmo, and E. Joelianto, “Open Source OPC UA Data Traffic Characteristic and Anomaly Detection using Image-Encoding based Convolutional Neural Network,” in </span><span class="font10" style="font-style:italic;">2022 7th International Conference on Electric Vehicular Technology (ICEVT)</span><span class="font10">, Bali, Indonesia: &nbsp;&nbsp;IEEE, Sep. 2022, pp. 52–59. doi:</span></p></li></ul>
<p><span class="font10">10.1109/ICEVT55516.2022.9925002.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font10">[8] &nbsp;&nbsp;&nbsp;S. Oh, S. Oh, T.-W. Um, J. Kim, and Y.-A. Jung, “Methods of PreClustering and Generating Time Series Images for Detecting Anomalies in Electric Power Usage Data,” </span><span class="font10" style="font-style:italic;">Electronics</span><span class="font10">, vol. 11, no. 20, p. 3315, Oct. 2022, doi: 10.3390/electronics11203315.</span></p></li>
<li>
<p><span class="font10">[9] &nbsp;&nbsp;&nbsp;C.-C. Wang and C.-H. Kuo, “Detecting dyeing machine entanglement anomalies by using time series image analysis and deep learning techniques for dyeing-finishing process,” </span><span class="font10" style="font-style:italic;">Adv. Eng. Inform.</span><span class="font10">, vol. 55, p. 101852, Jan. 2023, doi: 10.1016/j.aei.2022.101852.</span></p></li>
<li>
<p><span class="font10">[10] &nbsp;&nbsp;&nbsp;G. Liu, Y. Niu, W. Zhao, Y. Duan, and J. Shu, “Data anomaly detection for structural health monitoring using a combination network of GANomaly and CNN,” </span><span class="font10" style="font-style:italic;">Smart Struct. Syst.</span><span class="font10">, vol. 29, no. 1, pp. 53–62, Jan. 2022, doi: 10.12989/SSS.2022.29.1.053.</span></p></li>
<li>
<p><span class="font10">[11] &nbsp;&nbsp;&nbsp;H. Y. Yatbaz, E. Ever, and A. Yazici, “Activity Recognition and Anomaly Detection in E-Health Applications Using Color-Coded Representation and Lightweight CNN Architectures,” </span><span class="font10" style="font-style:italic;">IEEE Sens. J.</span><span class="font10">, vol. 21, no. 13, pp. 14191–14202, Jul. 2021, doi: 10.1109/JSEN.2021.3061458.</span></p></li></ul>
<p><span class="font12">Helmy Rahadian: Analisis Komputasi Paralel pada …</span></p>
<div>
<ul style="list-style:none;"><li>
<p><span class="font10">[12] &nbsp;&nbsp;&nbsp;J. Faouzi and H. Janati, “pyts: A Python Package for Time Series Classification,” </span><span class="font10" style="font-style:italic;">J. Mach. Learn. Res.</span><span class="font10">, vol. 21, no. 46, pp. 1–6, 2020.</span></p></li>
<li>
<p><span class="font10">[13] &nbsp;&nbsp;&nbsp;T. Fu, “A review on time series data mining,” </span><span class="font10" style="font-style:italic;">Eng. Appl. Artif. Intell.</span><span class="font10">, vol. 24, no. 1, pp. 164–181, Feb. 2011, doi: 10.1016/j.engappai.2010.09.007.</span></p></li>
<li>
<p><span class="font10">[14] &nbsp;&nbsp;&nbsp;W. Jiang, “Time series classification: nearest neighbor versus deep learning models,” </span><span class="font10" style="font-style:italic;">SN Appl. Sci.</span><span class="font10">, vol. 2, no. 4, p. 721, Apr. 2020, doi: 10.1007/s42452-020-2506-9.</span></p></li>
<li>
<p><span class="font10">[15] &nbsp;&nbsp;&nbsp;B. Lindemann, B. Maschler, N. Sahlab, and M. Weyrich, “A survey on anomaly detection for technical systems using LSTM networks,” </span><span class="font10" style="font-style:italic;">Comput. Ind.</span><span class="font10">, &nbsp;&nbsp;&nbsp;&nbsp;vol. &nbsp;&nbsp;&nbsp;&nbsp;131, &nbsp;&nbsp;&nbsp;&nbsp;p. &nbsp;&nbsp;&nbsp;&nbsp;103498, &nbsp;&nbsp;&nbsp;&nbsp;Oct. &nbsp;&nbsp;&nbsp;&nbsp;2021, &nbsp;&nbsp;&nbsp;&nbsp;doi:</span></p></li></ul>
<p><span class="font10">10.1016/j.compind.2021.103498.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font10">[16] &nbsp;&nbsp;&nbsp;I. González, A. J. Calderón, J. Figueiredo, and J. M. C. Sousa, “A Literature Survey on Open Platform Communications (OPC) Applied to Advanced Industrial Environments,” </span><span class="font10" style="font-style:italic;">Electronics</span><span class="font10">, vol. 8, no. 5, p. 510, May 2019, doi: 10.3390/electronics8050510.</span></p></li>
<li>
<p><span class="font10">[17] &nbsp;&nbsp;&nbsp;A. Cartwright, “OPC-UA: the Flow of Data,” </span><span class="font10" style="font-style:italic;">Ai Build TechBlog</span><span class="font10">, May 27, &nbsp;2021. &nbsp;</span><a href="https://medium.com/ai-build-techblog/opc-ua-the-flow-of-"><span class="font10">https://medium.com/ai-build-techblog/opc-ua-the-flow-of-</span></a></p></li></ul>
<p><span class="font10">data-7c3e5c870a4c (accessed May 21, 2023).</span></p>
<ul style="list-style:none;"><li>
<p><span class="font10">[18] &nbsp;&nbsp;&nbsp;N. Muhlbauer, E. Kirdan, M.-O. Pahl, and G. Carle, “Open-Source OPC UA Security and Scalability,” in </span><span class="font10" style="font-style:italic;">2020 25th IEEE International Conference on Emerging Technologies and Factory Automation (ETFA)</span><span class="font10">, Vienna, Austria: &nbsp;&nbsp;IEEE, Sep. 2020, pp. 262–269. doi:</span></p></li></ul>
<p><span class="font10">10.1109/ETFA46521.2020.9212091.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font10">[19] &nbsp;&nbsp;&nbsp;Z. Wang and T. Oates, “Imaging time-series to improve classification and imputation,” in </span><span class="font10" style="font-style:italic;">Twenty-Fourth International Joint Conference on Artificial Intelligence</span><span class="font10">, 2015.</span></p></li>
<li>
<p><span class="font10">[20] &nbsp;&nbsp;&nbsp;M. Wang, W. Wang, X. Zhang, and H. H.-C. Iu, “A New Fault Diagnosis of Rolling Bearing Based on Markov Transition Field and CNN,” </span><span class="font10" style="font-style:italic;">Entropy</span><span class="font10">, vol. 24, no. 6, p. 751, May 2022, doi: 10.3390/e24060751.</span></p></li>
<li>
<p><span class="font10">[21] &nbsp;&nbsp;&nbsp;I. A. S. Dewi Paramitha, G. M. A. Sasmita, and I. M. S. Raharja, “Analisis Data Log IDS Snort dengan Algoritma Clustering Fuzzy C-Means,” </span><span class="font10" style="font-style:italic;">Maj. Ilm. Teknol. Elektro</span><span class="font10">, vol. 19, no. 1, p. 95, Oct. 2020, doi: 10.24843/MITE.2020.v19i01.P14.</span></p></li>
<li>
<p><span class="font10">[22] &nbsp;&nbsp;&nbsp;A. Jayadi, T. Susanto, and F. D. Adhinata, “Sistem Kendali Proporsional pada Robot Penghindar Halangan (Avoider) Pioneer P3-DX,” </span><span class="font10" style="font-style:italic;">Maj. Ilm. Teknol. Elektro</span><span class="font10">, vol. 20, no. 1, p. 47, Mar. 2021, doi: 10.24843/MITE.2021.v20i01.P05.</span></p></li>
<li>
<p><span class="font10">[23] &nbsp;&nbsp;&nbsp;Q. Kong, T. Siauw, and A. M. Bayen, </span><span class="font10" style="font-style:italic;">Python programming and numerical methods: a guide for engineers and scientists</span><span class="font10">. London: Elsevier, Academic Press, 2021.</span></p></li>
<li>
<p><span class="font10">[24] &nbsp;&nbsp;&nbsp;“Python Multiprocessing: The Complete Guide,” </span><span class="font10" style="font-style:italic;">Super Fast Python</span><span class="font10">, Jun. 26, &nbsp;&nbsp;2022. &nbsp;&nbsp;</span><a href="https://superfastpython.com/multiprocessing-in-python/"><span class="font10">https://superfastpython.com/multiprocessing-in-python/</span></a></p></li></ul>
<p><span class="font10">(accessed Feb. 26, 2023).</span></p>
<ul style="list-style:none;"><li>
<p><span class="font10">[25] &nbsp;&nbsp;&nbsp;T. Kim, Y. Cha, B. Shin, and B. Cha, “Survey and Performance Test of Python-based Libraries for Parallel Processing,” in </span><span class="font10" style="font-style:italic;">The 9th International Conference on Smart Media and Applications</span><span class="font10">, Jeju Republic of Korea: ACM, Sep. 2020, pp. 154–157. doi: 10.1145/3426020.3426057.</span></p></li>
<li>
<p><span class="font10">[26] &nbsp;&nbsp;&nbsp;S. Jansen, “MPIRE for Python: MultiProcessing Is Really Easy!,” </span><span class="font10" style="font-style:italic;">Medium</span><span class="font10">, Oct. 27, 2021. </span><a href="https://towardsdatascience.com/mpire-for-"><span class="font10">https://towardsdatascience.com/mpire-for-</span></a></p></li></ul>
<p><span class="font10">python-multiprocessing-is-really-easy-d2ae7999a3e9 (accessed Feb. 22, 2023).</span></p>
<ul style="list-style:none;"><li>
<p><span class="font10">[27] &nbsp;&nbsp;&nbsp;“joblib/joblib.” joblib, Feb. 26, 2023. Accessed: Feb. 26, 2023. [Online]. Available: </span><a href="https://github.com/joblib/joblib"><span class="font10">https://github.com/joblib/joblib</span></a></p></li>
<li>
<p><span class="font10">[28] &nbsp;&nbsp;&nbsp;“MPIRE (MultiProcessing Is Really Easy).” Slimmer AI, Feb. 20, 2023. Accessed: &nbsp;&nbsp;&nbsp;&nbsp;Feb. &nbsp;&nbsp;&nbsp;&nbsp;26, &nbsp;&nbsp;&nbsp;&nbsp;2023. &nbsp;&nbsp;&nbsp;&nbsp;[Online]. &nbsp;&nbsp;&nbsp;&nbsp;Available:</span></p></li></ul>
<p><a href="https://github.com/Slimmer-AI/mpire"><span class="font10">https://github.com/Slimmer-AI/mpire</span></a></p>
</div><br clear="all">
<div>
<p><span class="font12">p-ISSN:1693 – 2951; e-ISSN: </span><span class="font3">2503-2372</span></p>
</div><br clear="all">
<h2><a name="bookmark44"></a><span class="font14"><a name="bookmark45"></a>{Halaman ini sengaja dikosongkan}</span></h2>
<p><span class="font12">ISSN 1693 – 2951</span></p>
<p><span class="font12">Helmy Rahadian: Analisis Komputasi Paralel pada …</span></p>