---
layout: full_article
title: "Penerapan Teknik Fast Motion Estimation Pada Algoritma Frame Rate Up-Conversion Video"
author: "Ni Putu Widya Yuniari, I Made Oka Widyantara"
categories: prosidingcsgteis2013
canonical_url: https://jurnal.harianregional.com/prosidingcsgteis2013/full-7226 
citation_abstract_html_url: "https://jurnal.harianregional.com/prosidingcsgteis2013/id-7226"
citation_pdf_url: "https://jurnal.harianregional.com/prosidingcsgteis2013/full-7226"  
comments: true
---

<p><span class="font5" style="font-weight:bold;">B-004</span></p>
<p><span class="font3">Prosiding Conference on Smart-Green Technology in Electrical and Information Systems</span></p>
<p><span class="font3">Bali, 14-15 November 2013</span></p><a name="caption1"></a>
<h1><a name="bookmark0"></a><span class="font14"><a name="bookmark1"></a>Penerapan Teknik </span><span class="font14" style="font-style:italic;">Fast Motion Estimation</span><span class="font14"> Pada Algoritma </span><span class="font14" style="font-style:italic;">Frame Rate Up-Conversion</span><span class="font14"> Video</span></h1>
<h3><a name="bookmark2"></a><span class="font12"><a name="bookmark3"></a>Ni Putu Widya Yuniari, I Made Oka Widyantara</span></h3>
<p><span class="font11">Magister Teknik Elektro</span></p>
<p><span class="font11">Universitas Udayana</span></p>
<p><span class="font11">Denpasar-Bali, Indonesia</span></p>
<p><span class="font11">widyayuniari2010@gmail@com, </span><a href="mailto:oka.widyantara@unud.ac.id"><span class="font11">oka.widyantara@unud.ac.id</span></a></p>
<p><span class="font10" style="font-weight:bold;">Abstrak</span><span class="font10" style="font-weight:bold;font-style:italic;">— Video surveillance</span><span class="font10" style="font-weight:bold;"> merupakan salah satu aplikasi yang sering dimanfaatkan pada sistem keamanan yakni dengan menempatkan satu atau beberapa kamera untuk memantau suatu ruangan kemudian ditransmisikan ke dekoder. Pada jaringan yang memiliki keterbatasan bandwidth transmisi, untuk tetap memperoleh video dengan resolusi tinggi terdapat suatu mekanisme yakni pada sisi enkoder harus menurunkan frame rate dengan mengirimkan sebagian dari urutan video asli. Sedangkan di dekoder harus mengupgrade kembali frame rate tersebut dengan suatu teknik yang dinamakan </span><span class="font10" style="font-weight:bold;font-style:italic;">Frame Rate Up-Conversion</span><span class="font10" style="font-weight:bold;"> (FRUC)</span><span class="font10" style="font-weight:bold;font-style:italic;">.</span><span class="font10" style="font-weight:bold;"> FRUC merupakan suatu teknik menyisipkan sebuah frame yang baru </span><span class="font10" style="font-weight:bold;font-style:italic;">(intermediate)</span><span class="font10" style="font-weight:bold;"> ke dalam suatu urutan video asli untuk meningkatkan frame rate</span><span class="font10" style="font-weight:bold;font-style:italic;">.</span><span class="font10" style="font-weight:bold;"> Salah satu teknik FRUC adalah </span><span class="font10" style="font-weight:bold;font-style:italic;">Motion Compensation Interpolation </span><span class="font10" style="font-weight:bold;">(</span><span class="font10" style="font-weight:bold;font-style:italic;">MCI</span><span class="font10" style="font-weight:bold;">). Teknik ini menyandarkan pada suatu proses yang disebut </span><span class="font10" style="font-weight:bold;font-style:italic;">Motion Estimation</span><span class="font10" style="font-weight:bold;"> (ME). Proses ME untuk algoritma MCI pada FRUC yakni memprediksikan posisi frame berupa </span><span class="font10" style="font-weight:bold;font-style:italic;">Motion Vector </span><span class="font10" style="font-weight:bold;">(MV) yang sekarang berdasarkan pada frame referensi. MV yang telah diperoleh disimpan di dekoder sebagai informasi yang digunakan untuk penyisipan frame </span><span class="font10" style="font-weight:bold;font-style:italic;">intermediate</span><span class="font10" style="font-weight:bold;">. Terdapat suatu metode untuk mempercepat proses ME dengan mengurangi jumlah blok kandidat yang disebut </span><span class="font10" style="font-weight:bold;font-style:italic;">Fast Search</span><span class="font10" style="font-weight:bold;">. Salah satu metode </span><span class="font10" style="font-weight:bold;font-style:italic;">Fast Search</span><span class="font10" style="font-weight:bold;"> adalah </span><span class="font10" style="font-weight:bold;font-style:italic;">Three Step Search</span><span class="font10" style="font-weight:bold;"> {TSS). Dengan mengadopsi pengkodean video berbasis blok, pada paper ini mengajukan penerapan teknik </span><span class="font10" style="font-weight:bold;font-style:italic;">Fast Search</span><span class="font10" style="font-weight:bold;"> TSS untuk ME pada algoritma FRUC. Sasarannya adalah menurunkan kompleksitas di enkoder dengan mengurangi jumlah kandidat blok pencarian dan untuk memberikan informasi MV frame </span><span class="font10" style="font-weight:bold;font-style:italic;">intermediate</span><span class="font10" style="font-weight:bold;"> yang akan disisipkan pada dekoder sehingga mampu meningkatkan frame rate.</span></p>
<p><span class="font10" style="font-weight:bold;">Kata kunci: </span><span class="font10" style="font-weight:bold;font-style:italic;">Motion Compensation Interpolation</span><span class="font10" style="font-weight:bold;">, </span><span class="font10" style="font-weight:bold;font-style:italic;">Motion Estimation</span><span class="font10" style="font-weight:bold;"> , </span><span class="font10" style="font-weight:bold;font-style:italic;">Fast Search</span><span class="font10" style="font-weight:bold;"> , </span><span class="font10" style="font-weight:bold;font-style:italic;">Three Step Search</span><span class="font10" style="font-weight:bold;">.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">I. &nbsp;&nbsp;&nbsp;Pendahuluan</span></p></li></ul>
<p><span class="font11">Perkembangan teknologi berbasis digital video saat ini cukup pesat. Salah satu pemanfaatan teknologi digital video yang telah banyak diterapkan adalah pada sistem keamanan ruang. </span><span class="font11" style="font-style:italic;">Video surveillance</span><span class="font11"> merupakan salah satu aplikasi yang sering dimanfaatkan pada sistem keamanan yakni dengan menempatkan satu atau beberapa kamera untuk memantau suatu ruangan kemudian ditransmisikan ke dekoder. Pada jaringan yang memiliki keterbatasan bandwidth transmisi, untuk tetap memperoleh video dengan resolusi tinggi maka terdapat suatu mekanisme yakni pada sisi enkoder harus menurunkan frame rate dengan mengirimkan sebagian dari</span></p>
<p><span class="font11">urutan video asli. Sedangkan di dekoder harus mengupgrade kembali frame rate tersebut dengan suatu teknik yang dinamakan </span><span class="font11" style="font-style:italic;">Frame Rate Up-Conversion FRUC</span><span class="font11">).</span></p>
<p><span class="font11">FRUC merupakan suatu teknik menyisipkan sebuah frame yang baru (</span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11">) ke dalam suatu urutan video asli untuk meningkatkan frame rate. Aplikasi ini digunakan dalam pengolahan sinyal video untuk mengatasi keterbatasan bandwidth transmisi untuk meningkatkan resolusi temporal. Secara umum algorima FRUC terbagi menjadi dua kategori. Kategori pertama tidak mempertimbangkan informasi dari pergerakan objek yakni dengan metode </span><span class="font11" style="font-style:italic;">Frame Repetition</span><span class="font11"> dan </span><span class="font11" style="font-style:italic;">Frame Averaging</span><span class="font11">. Proses dari metode ini mudah diimplementasikan namun memberikan kualitas visual yang rendah seperti kabur dan </span><span class="font11" style="font-style:italic;">artifact</span><span class="font11"> untuk objek yang bergerak. Kategori kedua dengan mempertimbangkan informasi dari pergerakan video yakni dengan metode </span><span class="font11" style="font-style:italic;">Motion Compensation Interpolation</span><span class="font11"> (</span><span class="font11" style="font-style:italic;">MCI</span><span class="font11">). Teknik </span><span class="font11" style="font-style:italic;">MCI</span><span class="font11"> menyandarkan pada suatu proses yang disebut </span><span class="font11" style="font-style:italic;">Motion Estimation</span><span class="font11"> (ME). Proses ME untuk algoritma MCI pada FRUC yakni memprediksikan posisi frame berupa </span><span class="font11" style="font-style:italic;">Motion Vecto</span><span class="font11">r (MV) yang sekarang berdasarkan pada frame referensi. MV yang telah diperoleh sebagai informasi yang digunakan untuk frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11">.</span></p>
<p><span class="font11">Terdapat algoritma ME yang diterapkan untuk FRUC [1-3]. Metode ME ini dilakukan hanya berdasarkan pada arah mundur yakni menggunakan frame sebelumnya sebagai frame referensi dengan menyalin MV dari frame yang sebelumnya menjadi MV untuk frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11">. Akan tetapi metode ini memberikan pergerakan video yang buruk. Untuk mengatasi hal ini maka terdapat suatu metode yang menerapkan teknik kombinasi linier yakni menggunakan frame referensi pada dua sisi yakni frame sebelum (arah mundur) dan selanjutnya (arah maju) untuk informasi frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11">. Choi et al [4] mengusulkan metode MCI menggunakan teknik </span><span class="font11" style="font-style:italic;">Bilateral</span><span class="font11"> ME. Namun teknik ini memiliki kompleksitas yang tinggi. Untuk mengurangi kompleksitas, Zhang et al [5] mengusulkan metode ME </span><span class="font11" style="font-style:italic;">Unidirectional</span><span class="font11"> untuk algoritma FRUC.</span></p>
<p><span class="font11">Algoritma [1-5] menggunakan metode pencarian ME </span><span class="font11" style="font-style:italic;">Full Search</span><span class="font11">. Dengan mengadopsi pengkodean video berbasis blok, metode </span><span class="font11" style="font-style:italic;">Full Search</span><span class="font11"> mencari sebuah kandidat blok terbaik pada semua posisi blok di frame referensi dengan jendela pencarian yang ditetapkan [6]. Terdapat sebuah argumentasi bahwa ME dengan metode pencarian </span><span class="font11" style="font-style:italic;">Full Search</span><span class="font11"> ini membutuhkan proses pencarian kandidat blok terbaik dengan</span></p>
<p><span class="font11">waktu yang lama sehingga menyebabkan kompleksitas enkoder video menjadi lebih tinggi. Suatu metode yang dapat digunakan untuk mengurangi jumlah kandidat blok untuk proses ME disebut </span><span class="font11" style="font-style:italic;">Fast Search</span><span class="font11">. Salah satu metode </span><span class="font11" style="font-style:italic;">Fast Search</span><span class="font11"> adalah </span><span class="font11" style="font-style:italic;">Three Step Search</span><span class="font11"> (TSS). TSS melakukan proses pencarian sebuah kandidat blok terbaik melalui tiga langkah. Pada paper ini mengajukan penerapan teknik TSS untuk ME pada algoritma FRUC. Sasarannya adalah menurunkan kompleksitas di enkoder dengan mengurangi jumlah kandidat blok pencarian dan untuk memberikan informasi MV frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11"> yang akan disisipkan pada dekoder sehingga mampu meningkatkan frame rate. Untuk saat ini penelitian masih dalam progress.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">II. &nbsp;&nbsp;&nbsp;Teknik </span><span class="font11" style="font-style:italic;">Motion Estimation</span><span class="font11"> Fruc Dengan Mci</span></p></li></ul>
<p><span class="font11">Metode FRUC dengan teknik MCI menggunakan 2 frame yang telah didekodekan sebelumnya sebagai frame referensi yakni frame sebelum dan sesudahnya. Terdapat beberapa teknik MCI yang digunakan pada algoritma FRUC yakni sebagai berikut:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11" style="font-style:italic;">A. &nbsp;&nbsp;&nbsp;Unidirectional ME</span></p></li></ul>
<p><span class="font11">Dari 2 buah frame yang telah didekodekan yakni frame f</span><span class="font8">t-1 </span><span class="font11">dan f</span><span class="font8">t+1 </span><span class="font11">maka untuk mencari frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11"> sebagai frame interpolasi f</span><span class="font8">t </span><span class="font11">dapat dimodelkan sebagai berikut:</span></p>
<ul style="list-style:none;"><li>
<p><a href="#bookmark4"><span class="font13">1 &nbsp;&nbsp;11 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11</span></a></p></li></ul>
<p><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t</span><span class="font11">(x,y)= &nbsp;&nbsp;</span><span class="font13" style="font-style:italic;">f</span><span class="font11" style="font-style:italic;"><sub>t</sub></span><span class="font1"><sub>-</sub></span><span class="font13"><sub>1</sub></span><span class="font11">(x - Δx, y- &nbsp;&nbsp;Δy) + </span><span class="font11" style="font-style:italic;">f</span><span class="font8">t+1</span><span class="font11">(x + Δx, y + Δy) +</span></p>
<p><a href="#bookmark5"><span class="font11">η</span><span class="font8">t</span><span class="font11">(x,y)(1)</span></a></p>
<p><span class="font11">Dimana (x,y) dan (Δx, Δy) adalah posisi píxel dan unidirectional MV masing-masing dari arah x dan y. Δx dan Δy dicari berdasarkan metode pencarían </span><span class="font11" style="font-style:italic;">Full Search</span><span class="font11">.</span></p>
<p><a href="#bookmark6"><span class="font11">MV terbaik untuk frame </span><span class="font11" style="font-style:italic;">intermédiate</span><span class="font11"> adalah nilai rata-rata terkecil dari pengurangan sisi maju dan mundur. Maka, Δv = (Δx,Δy) = arg </span><span class="font13">min</span><span class="font11" style="font-style:italic;">ρ</span><span class="font11">(</span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-</span><span class="font8">1</span><span class="font11">, </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t+1</span><span class="font8">; </span><span class="font11">Δx, Δy)(2)</span></a></p>
<p><span class="font7">Δ</span><span class="font8" style="font-style:italic;">x</span><span class="font8">,</span><span class="font7">Δ</span><span class="font8" style="font-style:italic;">y</span></p>
<p><span class="font11">Nilai </span><span class="font11" style="font-style:italic;">ρ</span><span class="font11"> adalah fungsi jarak yang tepat. Untuk estimasi gerak </span><span class="font11" style="font-style:italic;">unidirectional</span><span class="font11"> nilai </span><span class="font11" style="font-style:italic;">ρ</span><span class="font11"> dari arah maju dapat didefinisikan sebagai berikut:</span></p>
<p><span class="font11" style="font-style:italic;">ρ</span><span class="font11">(</span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-</span><span class="font8">1</span><span class="font11">, </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t+1</span><span class="font8">; </span><span class="font11">Δx, Δy) = </span><span class="font4">Σ </span><span class="font13">|</span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-1</span><span class="font11">(x,y)-</span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t+1</span><span class="font11">(x+Δx, y+Δy)| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)</span></p>
<p><span class="font8" style="font-style:italic;">x</span><span class="font8">,</span><span class="font8" style="font-style:italic;">y</span><span class="font7">∈ </span><span class="font8" style="font-style:italic;">G</span></p>
<p><span class="font11">untuk arah mundur dapat didefinisikan sebagai berikut:</span></p>
<p><span class="font11" style="font-style:italic;">ρ</span><span class="font11">(</span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-</span><span class="font8">1</span><span class="font11">, </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t+1</span><span class="font8">; </span><span class="font11">Δx, Δy) = </span><span class="font4">Σ </span><span class="font13">| </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t+1</span><span class="font11">(x,y) - </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-1</span><span class="font11">(x+Δx, y+Δy)| &nbsp;&nbsp;&nbsp;&nbsp;(4)</span></p>
<p><span class="font8" style="font-style:italic;">x</span><span class="font8">,</span><span class="font8" style="font-style:italic;">y</span><span class="font7">∈ </span><span class="font8" style="font-style:italic;">G</span></p>
<p><span class="font11">Nilai G adalah grup dari píxel , biasanya adalah ukuran blok dari sebuah gambar. Pada usulan ini menggunakan blok 8x8.</span></p>
<p><span class="font11">Pada sisi tepi biasanya memiliki informasi yang akurat sehingga mudah diketahui oleh persepsi visual. Untuk meningkatkan kualitas ME dan mempertajam sisi tepi maka nilai </span><span class="font11" style="font-style:italic;">ρ</span><span class="font11"> didefinisikan sebagai berikut:</span></p>
<p><span class="font11" style="font-style:italic;">ρ</span><span class="font11">(</span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-</span><span class="font8">1</span><span class="font11">, </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t+1</span><span class="font8">; </span><span class="font11">Δx, Δy) = </span><span class="font4">Σ </span><span class="font13">| </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-1</span><span class="font11">(x,y)- </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t+1</span><span class="font11">(x-Δx, y-Δy)| + α | (D </span><span class="font8" style="font-style:italic;">x</span><span class="font8">,</span><span class="font8" style="font-style:italic;">y</span><span class="font7">∈ </span><span class="font8" style="font-style:italic;">G</span></p>
<p><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-1</span><span class="font11">)(x,y)-(D </span><span class="font11" style="font-style:italic;">ft+1</span><span class="font11">) (x-Δx, y-Δy) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5)</span></p>
<p><span class="font11">D adalah sebuah high pass filter, D </span><span class="font11" style="font-style:italic;">f<sub>t-1</sub></span><span class="font11"> menunjukkan konten frekuensi tinggi dari </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-1</span><span class="font11">. α adalah factor pembobotan yang dapat menyeimbangkan pengaruh dari dua perbedaan bentuk pada persamaan 5. [5] menggunakan nilai α adalah 0.3.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11" style="font-style:italic;">B. &nbsp;&nbsp;&nbsp;Bilateral ME</span></p></li></ul>
<p><span class="font11">Pada metode </span><span class="font11" style="font-style:italic;">Bilateral ME,</span><span class="font11"> persamaan yang digunakan untuk mencari MV frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11"> dapat dicari menggunakan persamaan 1 dan 2. Δx dan Δy pada metode </span><span class="font11" style="font-style:italic;">Bilateral ME</span><span class="font11"> juga menggunakan metode pencarían </span><span class="font11" style="font-style:italic;">Full Search</span><span class="font11">. Untuk nilai </span><span class="font11" style="font-style:italic;">ρ</span><span class="font11"> sebagai fungsi jarak yang tepat pada metode </span><span class="font11" style="font-style:italic;">Bilateral ME</span><span class="font11"> dari arah maju dapat didefinisikan sebagai berikut:</span></p>
<p><span class="font11" style="font-style:italic;">ρ</span><span class="font11">(</span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-</span><span class="font8">1</span><span class="font11">, </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t+1</span><span class="font8">; </span><span class="font11">Δx, Δy) = </span><span class="font4">Σ </span><span class="font13">| </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t-1</span><span class="font11">(x- Δx/2, y- Δy/2)- </span><span class="font11" style="font-style:italic;">f</span><span class="font8" style="font-style:italic;">t+1</span><span class="font11">(x+Δx/2, </span><span class="font8" style="font-style:italic;">x</span><span class="font8">,</span><span class="font8" style="font-style:italic;">y</span><span class="font7">∈ </span><span class="font8" style="font-style:italic;">G</span></p>
<p><span class="font11">y+Δy/2)| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6)</span></p>
<p><span class="font11">Untuk arah mundur dapat definisikan sebagai berikut:</span></p>
<p><span class="font11">ρ</span><span class="font11" style="font-style:italic;">(</span><span class="font11">f</span><span class="font8">t-</span><span class="font8" style="font-style:italic;">1</span><span class="font11" style="font-style:italic;">,</span><span class="font11"> f</span><span class="font8">t+1</span><span class="font8" style="font-style:italic;">; </span><span class="font11" style="font-style:italic;">Δx, Δy) =</span><span class="font4"> Σ </span><span class="font13">| </span><span class="font11">f</span><span class="font8">t+1</span><span class="font11">(x-Δx/2, y- Δy/2) </span><span class="font11" style="font-style:italic;">-</span><span class="font11"> f</span><span class="font8">t-1</span><span class="font11" style="font-style:italic;">(</span><span class="font11">x+Δx/2, </span><span class="font8" style="font-style:italic;">x</span><span class="font8">,</span><span class="font8" style="font-style:italic;">y</span><span class="font7">∈</span><span class="font8" style="font-style:italic;">G</span></p>
<p><span class="font11">y+Δy/2</span><span class="font11" style="font-style:italic;">)|</span><span class="font11"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7)</span></p>
<p><span class="font11">Secara umum, </span><span class="font11" style="font-style:italic;">Bilateral ME</span><span class="font11"> memiliki performansi lebih baik daripada metode Unidirectional, tetapi proses </span><span class="font11" style="font-style:italic;">Bilateral ME</span><span class="font11"> memiliki kompleksitas yang tinggi dibandingkan Unidirectional ME.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">III. &nbsp;&nbsp;&nbsp;Teknik </span><span class="font11" style="font-style:italic;">Fast Search Motion Estimation</span><span class="font11"> Pada MCI</span></p>
<ul style="list-style:none;">
<li>
<p><span class="font11">3.1 &nbsp;&nbsp;&nbsp;Teknik </span><span class="font11" style="font-style:italic;">Fast Search</span><span class="font11"> TSS</span></p></li></ul></li></ul>
<p><span class="font11">Teknik MCI pada FRUC yang telah disebutkan di atas yakni </span><span class="font11" style="font-style:italic;">Unidirectional</span><span class="font11"> dan </span><span class="font11" style="font-style:italic;">Bilateral</span><span class="font11"> menggunakan metode pencarian Δx dan Δy dengan metode </span><span class="font11" style="font-style:italic;">Full Search</span><span class="font11">. Dengan menggunakan </span><span class="font11" style="font-style:italic;">Full Search</span><span class="font11"> jumlah kandidat blok n untuk blok berukuran panjang b</span><span class="font8">w </span><span class="font11">dan lebar b</span><span class="font8">h </span><span class="font11">dan jendela pencarian dengan panjang W dan lebar H (dimana W ≥ b</span><span class="font8">w </span><span class="font11">dan H ≥ b</span><span class="font8">h</span><span class="font11">) dapat dicari dengan persamaan berikut:</span></p>
<p><span class="font11">n= (W - b</span><span class="font8">w</span><span class="font11">+1) * (H - b</span><span class="font8">h</span><span class="font11">+1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(8)</span></p>
<p><span class="font11">Misalkan untuk b<sub>w</sub> dan b<sub>h</sub> =16 dan W,H=30. Maka jumlah kandidat blok n adalah 225 blok. Mencari sebuah kandidat blok terbaik keseluruhan frame adalah hal yang mungkin namun secara praktis tidak layak terutama untuk resolusi tinggi, misalkan b<sub>w</sub> dan b<sub>h</sub> =16 dan W= 1920 dan H=1080. Maka total terdapat 2.028.825 kandidat blok. Kandidat blok terbaik (</span><span class="font11" style="font-style:italic;">best match</span><span class="font11">) di peroleh dari nilai </span><span class="font11" style="font-style:italic;">Mean Square Error </span><span class="font11">(MSE) terkecil yang dihitung untuk setiap kandidat blok [7] menggunakan persamaan berikut:</span></p>
<p><span class="font8" style="font-style:italic;">N</span><span class="font7">-</span><span class="font8">1 </span><span class="font8" style="font-style:italic;">N</span><span class="font7">-</span><span class="font8">1</span></p>
<p><span class="font11">MSE =</span><span class="font11" style="font-style:italic;"><sub>N</sub></span><span class="font13">1<sub>2</sub> </span><span class="font6">∑∑</span><span class="font13">(</span><span class="font13" style="font-style:italic;">Cij</span><span class="font4">-</span><span class="font13" style="font-style:italic;">Rij</span><span class="font13">)<sup>2</sup> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font11">(9)</span></p>
<p><span class="font8" style="font-style:italic;">i</span><span class="font7">=</span><span class="font8">0 </span><span class="font8" style="font-style:italic;">j</span><span class="font7">=</span><span class="font8">0</span></p>
<p><span class="font11">Hal ini tentu membutuhkan waktu yang lama dan komputasi yang berat. Terdapat suatu metode untuk mempercepat proses ME dengan mengurangi jumlah kandidat blok untuk algoritma FRUC yakni </span><span class="font11" style="font-style:italic;">Fast Search</span><span class="font11">, salah satunya adalah algoritma TSS.</span></p>
<p><span class="font11">Metode TSS merupakan salah satu metode pertama untuk teknik pencocokan blok [8] untuk mengurangi proses dari </span><span class="font11" style="font-style:italic;">Full Search</span><span class="font11">. TSS melakukan pencarian untuk mendapatkan sebuah kandidat blok terbaik melalui tiga langkah secara iterative, yakni :</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">1. &nbsp;&nbsp;&nbsp;Langkah I: Cocokkan dengan semua posisi termasuk dengan posisi tengah pada jarak sejauh 4 pixel dari posisi tengah. Pada langkah ini melibatkan 9 blok pencarian, s</span><span class="font8">1</span><span class="font11">=9.</span></p></li>
<li>
<p><span class="font11">2. &nbsp;&nbsp;&nbsp;Langkah II: Pusatkan wilayah pencarian sekitar kandidat blok terbaik dari langkah I. Cocokkan semua pixel pada jarak sejauh 2 pixel dari posisi tengah. Pada langkah ini melibatkan 8 blok pencarian, s</span><span class="font8">2</span><span class="font11">=8.</span></p></li>
<li>
<p><span class="font11">3. &nbsp;&nbsp;&nbsp;Langkah III: Pusatkan wilayah pencarian sekitar kandidat blok terbaik dari langkah II. Cocokkan semua pixel pada jarak sejauh 1 pixel dari posisi tengan. Pada langkah ini melibatkan 8 blok pencarian, s</span><span class="font8">3</span><span class="font11">=8. Kandidat terbaik ditemukan pada langkah ini.</span></p></li></ul>
<p><span class="font11">Pada algoritma TSS hanya melibatkan pencarian terhadap 25 kandidat blok. Proses TSS dapat dilihat pada gambar 1.</span></p>
<p><span class="font11">n=s<sub>1</sub>+s<sub>2</sub>+s<sub>3</sub>=25</span></p>
<p><span class="font11">Jika bw dan bh yang digunakan adalah 16 dan W,H adalah 30. Maka TSS menunjukkan kompleksitas 9x lebih rendah dibandingkan proses </span><span class="font11" style="font-style:italic;">Full Search</span><span class="font11">.</span></p><img src="https://jurnal.harianregional.com/media/7226-1.jpg" alt="" style="width:186pt;height:184pt;">
<p><span class="font0" style="font-weight:bold;">• Stepl</span></p>
<p><span class="font0" style="font-weight:bold;">■ StepZ</span></p>
<p><span class="font0" style="font-weight:bold;">A Step 3</span></p>
<p><span class="font9" style="font-variant:small-caps;">g</span><span class="font9">ambar 1 </span><span class="font9" style="font-variant:small-caps;">i</span><span class="font9">lustrasi </span><span class="font9" style="font-variant:small-caps;">a</span><span class="font9">lgoritma </span><span class="font9" style="font-variant:small-caps;">tss</span><span class="font9"> [8</span><span class="font11">]</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">3.2 &nbsp;&nbsp;&nbsp;Penerapan Metode TSS Pada </span><span class="font11" style="font-style:italic;">Unidirectional</span><span class="font11"> ME</span></p></li></ul>
<p><span class="font11">Teknik pencarian MV yang diusulkan untuk algoritma FRUC pada penelitian ini adalah </span><span class="font11" style="font-style:italic;">Fast Search</span><span class="font11"> yakni menggunakan metode TSS. MV frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11"> dicari menggunakan langkah-langkah pada persamaan </span><span class="font11" style="font-style:italic;">Unidirectional</span><span class="font11"> ME yang telah disebutkan pada persamaan (1)(5) di atas. Namun untuk Δx dan Δy dicari menggunakan metode TSS yang telah jelaskan pada sub bab 3.1 di atas.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">IV. &nbsp;&nbsp;&nbsp;Model Implementasi </span><span class="font11" style="font-style:italic;">Fast Search</span><span class="font11"> ME Pada FRUC</span></p></li></ul>
<p><span class="font11">Untuk analisis metode yang diusulkan dalam penelitian ini menerapkan model transmisi video pada aplikasi </span><span class="font11" style="font-style:italic;">video surveillance</span><span class="font11">. Dari gambar 2 dapat dilihat bahwa enkoder mengirimkan video dengan frame rate yang rendah dengan hanya mengirimkan sebagian dari urutan video asli dengan mendrop beberapa frame video (frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11">). Teknik </span><span class="font11" style="font-style:italic;">Fast Search</span><span class="font11"> yakni TSS untuk proses ME diimplementasikan untuk memprediksikan MV dari frame </span><span class="font11" style="font-style:italic;">intermediate </span><span class="font11">menggunakan frame sebelum dan sesudahnya sebagai frame referensi. Pada dekoder harus melakukan proses FRUC dengan menyisipkan kembali frame yang di drop di enkoder ke dalam urutan video asli sehingga frame rate meningkat menggunakan informasi MV dari frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11"> yang diperoleh dari teknik TSS</span></p>
<p><span class="font11">Source video</span></p><img src="https://jurnal.harianregional.com/media/7226-2.jpg" alt="" style="width:178pt;height:121pt;">
<p><span class="font2" style="font-weight:bold;">Up-converted video</span></p>
<p><span class="font9">Gambar 2 Ilustrasi Algoritma FRUC [6]</span></p>
<p><span class="font11">Untuk evaluasi kualitas secara objective dari frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11"> yang disisipkan di sisi dekoder digunakan pengukuran </span><span class="font11" style="font-style:italic;">Peak Signal To Noise Ratio</span><span class="font11"> (PSNR) [8]. Asumsi yang digunakan adalah frame yang di drop disimpan di enkoder untuk kemudian dibandingkan dengan frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11"> yang dihasilkan di dekoder. Persamaan PSNR dapat dilihat dibawah ini.</span></p>
<p><span class="font8" style="font-style:italic;">k</span><span class="font8">2</span></p>
<p><span class="font11">PSNR=10 log</span><span class="font8">10 </span><span class="font13">( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</span></p>
<h2><a name="bookmark7"></a><span class="font13" style="font-style:italic;"><a name="bookmark8"></a>MSE</span></h2>
<div>
<p><span class="font11">(10)</span></p>
</div><br clear="all">
<p><span class="font11">k adalah jumlah bit dalam 1 sampel pixel. Nilai PSNR ini digunakan untuk menganalisis kinerja </span><span class="font11" style="font-style:italic;">Fast MCI</span><span class="font11"> pada model implementasi </span><span class="font11" style="font-style:italic;">video surveillance</span><span class="font11">.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">V. &nbsp;&nbsp;&nbsp;KESIMPULAN</span></p></li></ul>
<p><span class="font11">FRUC merupakan suatu teknik menyisipkan sebuah frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11"> ke dalam suatu urutan video asli untuk meningkatkan frame rate. Aplikasi ini digunakan dalam pengolahan sinyal video untuk mengatasi keterbatasan</span></p>
<p><span class="font11">bandwidth transmisi untuk meningkatkan resolusi temporal. Salah satu teknik FRUC yakni dengan metode MCI. Teknik MCI mempertimbangkan informasi dari pergerakan video dengan menyandarkan pada suatu proses yang disebut </span><span class="font11" style="font-style:italic;">Motion Estimation</span><span class="font11"> (ME). Proses ME untuk algoritma MCI pada FRUC yakni memprediksikan posisi frame berupa </span><span class="font11" style="font-style:italic;">Motion Vecto</span><span class="font11">r yang sekarang berdasarkan pada frame referensi. Frame referensi yang digunakan pada penelitian ini adalah dari dua sisi yakni frame sebelum (arah mundur) dan selanjutnya (arah maju). Suatu metode untuk mempercepat proses ME dengan mengurangi jumlah kandidat blok pencarian disebut </span><span class="font11" style="font-style:italic;">Fast Search</span><span class="font11">. Salah satu metode </span><span class="font11" style="font-style:italic;">Fast Search </span><span class="font11">adalah </span><span class="font11" style="font-style:italic;">Three Step Search</span><span class="font11"> (TSS). TSS melakukan proses pencarian sebuah kandidat blok terbaik melalui tiga langkah. Pada penelitian ini mengajukan suatu teknik ME dengan metode </span><span class="font11" style="font-style:italic;">Fast Search</span><span class="font11"> TSS pada algoritma FRUC. Sasarannya adalah menurunkan kompleksitas di enkoder dengan mengurangi jumlah kandidat blok pencarian dan untuk memberikan informasi MV frame </span><span class="font11" style="font-style:italic;">intermediate</span><span class="font11"> yang akan disisipkan pada dekoder sehingga mampu meningkatkan frame rate. Untuk saat ini penelitian masih dalam progress.</span></p>
<p><span class="font11">REFERENSI</span></p>
<ul style="list-style:none;"><li>
<p><span class="font11">[1]</span><span class="font9"> &nbsp;&nbsp;&nbsp;G.D. Haan, P.W.A.C. Biezen, H. Huijgen, and O. A. Ojo, ”True-motion estimation with 3-D recursive search block matching,” IEEE Trans. Circuits Syst. Video Technol., vol. 3, no. 5, pp. 368-379, Oct. 1993.</span></p></li>
<li>
<p><span class="font9">[2] &nbsp;&nbsp;&nbsp;C.C. Cheng, W.L. Hwang, Z. Shen, and T. Xia, ”Advanced motion compensation techniques for blocking artifacts reduction in 3-D video coding sistems,” in Proc. ICIP, Sep. 2005, vol. 3, pp. 89-92.</span></p></li>
<li>
<p><span class="font9">[3] &nbsp;&nbsp;&nbsp;Y.K. Chen, A. Vetro, H. Sun, and S. Y. Kung, ”Frame-rate up-conversion using transmitted true motion vectors,” in Proc. IEEE Workshop Multimedia Signal Process., Dec. 1998, vol. 2, pp. 622-627.</span></p></li>
<li>
<p><span class="font9">[4] &nbsp;&nbsp;&nbsp;B.D. Choi, J.W. Han, C.S. Kim, and S. J. Ko, ”Motion-compensated frame interpolation using bilateral motion estimation and adaptive overlapped block motion compensation,” IEEE Trans. Circuits Syst. Video Technol.,vol. 17, no. 4, pp.407-416, Apr. 2007.</span></p></li>
<li>
<p><span class="font9">[5] &nbsp;&nbsp;&nbsp;L. Zhang, C. Wang, W. Zhang, and Y. P. Tan, “Frame Rate Up-Conversion With Edge-Weighted Motion Estimation and Trilateral Interpolation,“ IEEE Trans. Circuits Syst. Video Technol.,vol. 20, no. 6, pp. 886-893, June. 2010.</span></p></li>
<li>
<p><span class="font9">[6] &nbsp;&nbsp;&nbsp;A. Isberg, J. Jostell, “Frame Rate Up-Conversion Using High Definition Remote Video Surveillance,” Technical Report,” Dept. Of Computer Science and Engineering, Chalmers University Of Technology Sweden, Apr. 2012.</span></p></li>
<li>
<p><span class="font9">[7] &nbsp;&nbsp;&nbsp;A. Barjatya, Block Matching Algorithms For Motion Estimation, “Technical Report,” ECE Department at Utah State University. 2004.</span></p></li>
<li>
<p><span class="font9">[8] &nbsp;&nbsp;&nbsp;T. Koga, K. Linuma, A. Hirano, Y, and T. Ishigiro, “Motion Compensated Interframe Coding For Video Conferencing,” in Proc. National Telecommunication Conference,” pp 531-535, 1981.</span></p></li></ul>
<p><span class="font11">78</span></p>
<p><span class="font3">ISBN: 978-602-7776-72-2 © Universitas Udayana 2013</span></p>