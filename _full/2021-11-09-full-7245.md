---
layout: full_article
title: "Evaluasi Kinerja Rate-Distortion Dengan Penerapan Teknik Pembangkitan Side Information Pada Codec Wyner-Ziv Video Coding"
author: "Anak Agung Ayu Putri Ardyanti, I Made Oka Widyantara, Linawati ."
categories: prosidingcsgteis2013
canonical_url: https://jurnal.harianregional.com/prosidingcsgteis2013/full-7245 
citation_abstract_html_url: "https://jurnal.harianregional.com/prosidingcsgteis2013/id-7245"
citation_pdf_url: "https://jurnal.harianregional.com/prosidingcsgteis2013/full-7245"  
comments: true
---

<p><span class="font8" style="font-weight:bold;">B-010</span></p>
<p><span class="font5">Prosiding Conference on Smart-Green Technology in Electrical and Information Systems</span></p>
<p><span class="font5">Bali, 14-15 November 2013</span></p><a name="caption1"></a>
<h1><a name="bookmark0"></a><span class="font33"><a name="bookmark1"></a>Evaluasi Kinerja </span><span class="font33" style="font-style:italic;">Rate-Distortion</span><span class="font33"> Dengan Penerapan Teknik Pembangkitan </span><span class="font33" style="font-style:italic;">Side Information</span><span class="font33"> Pada Codec Wyner-Ziv </span><span class="font33" style="font-style:italic;">Video Coding</span></h1>
<p><span class="font26">Anak Agung Ayu Putri Ardyanti </span><span class="font25">Magister Teknik Elektro Universitas Udayana Denpasar, Indonesia </span><a href="mailto:putri.ardyanti@unud.ac.id"><span class="font25">putri.ardyanti@unud.ac.id</span></a></p>
<p><span class="font26">I Made Oka Widyantara </span><span class="font25">Lab. Sistem Telekomunikasi, Jurusan Teknik Elektro Universitas Udayana Denpasar, Indonesia </span><a href="mailto:oka.widyantara@unud.ac.id"><span class="font25">oka.widyantara@unud.ac.id</span></a></p>
<div>
<p><span class="font26">Linawati</span></p>
<p><span class="font25">Jurusan Teknik Elektro Universitas Udayana Denpasar, Indonesia </span><a href="mailto:linawati@unud.ac.id"><span class="font25">linawati@unud.ac.id</span></a></p>
</div><br clear="all">
<p><span class="font24" style="font-weight:bold;font-style:italic;">Abstrak</span><span class="font24" style="font-weight:bold;">—Wyner-Ziv Video Coding (WZVC) adalah paradigma baru dalam pengkodean video, dimana, ekploitasi korelasi temporal video dilakukan sepenuhnya di dekoder. Sasarannya adalah menurunkan kompleksitas enkoder, dengan menggeser teknik estimasi dan kompensasi gerak ke sisi dekoder. Skema umum WZVC adalah mendekodekan frame dari enkoder, dengan membangkitkan side information (SI) di dekoder. Semakin akurat frame SI yang yang dihasilkan untuk sebuah frame yang dikirimkan oleh enkoder, maka kinerja rate-distortion (RD) codec WZVC akan semakin baik. Saat ini telah dikembangkan dua codec WZVC dengan metode pembangkitan SI berbeda yaitu codec DISCOVER dan codec WZVC-EM. Codec DISCOVER menerapkan metode </span><span class="font25" style="font-weight:bold;font-style:italic;">bidirectional motion-compensated frame interpolation</span><span class="font25" style="font-weight:bold;"> (B-MCFI), dimana sebuah frame SI diperoleh dengan estimasi dan kompensasi gerak dua frame referensi yang tersedia di dekoder. Sedangkan codec WZVC-EM menerapkan metode pembelajan medan gerak secara iteratif berbasis pada algoritma Expectation-Maxization (EM). Metode ini akan memperbaharui medan gerak secara iteratif untuk meningkatkan akurasi soft SI. Paper ini akan mengevaluasi kinerja RD kedua codec tersebut pada struktur group of picture (GOP) berbeda. Sasarannya adalah untuk memperoleh kerangka kerja codec WZVC yang efisien untuk dikembangkan lebih lanjut. Hasil evaluasi menunjukan bahwa kinerja RD codec WZVC-EM lebih baik untuk ukuran GOP lebih besar dari dua.</span></p>
<p><span class="font24" style="font-weight:bold;">Kata Kunci</span><span class="font24" style="font-weight:bold;font-style:italic;">—Side Information</span><span class="font24" style="font-weight:bold;">, Wyner-Ziv </span><span class="font24" style="font-weight:bold;font-style:italic;">Video Coding, </span><span class="font24" style="font-weight:bold;">Codec DISCOVER, Codec WZVC-EM, Estimasi dan kompensasi gerak.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font25">I. &nbsp;&nbsp;&nbsp;PENDAHULUAN</span></p></li></ul>
<p><span class="font25">Perkembangan digital khususnya bidang video saat ini mengalami kemajuan yang sangat pesat mulai aplikasi </span><span class="font25" style="font-style:italic;">video on demand</span><span class="font25"> sampai tv </span><span class="font25" style="font-style:italic;">streaming.</span><span class="font25"> Pengkodean video konfensional seperti H.26x dan MPEG.x berbasis pengkodean prediktif dimana enkoder bekerja lebih tinggi daripada dekoder. Metode ini sangat cocok untuk media penyimpanan digital dan </span><span class="font25" style="font-style:italic;">video streaming</span><span class="font25"> karena sumber aplikasi dikodekan</span></p>
<p><span class="font25">sekali di enkoder dan didekodekan beberapa kali. Namun dalam aplikasinya metode ini tidak cocok untuk pengkodean video yang diterapkan seperti pada </span><span class="font25" style="font-style:italic;">wireless video surveillance, wireless</span><span class="font25"> PC </span><span class="font25" style="font-style:italic;">camera</span><span class="font25">, dimana seluruh aplikasi seperti ini menginginkan kinerja enkoder menjadi ringan. Munculah teknik pengkodean video berdasarkan teori informasi Slepian-Wolf (SW) [1] dan Wyner-Zip (WZ) [2] yaitu </span><span class="font25" style="font-style:italic;">Distributed Video Coding</span><span class="font25"> [3] yang sering disebut juga dengan DVC [1] [2]. Teorema ini menawarkan solusi dimana kinerja enkoder menjadi lebih rendah dengan memindahkan efisiensi medan gerak ke dekoder. Pengkodean sumber terdistribusi inilah yang menjadi dasar dari pengembangan Wyner-Ziv </span><span class="font25" style="font-style:italic;">Video Coding</span><span class="font25"> (WZVC). WZVC menerapkan teorema WZ dengan pembangkitan SI di dekoder. Dengan skema ini, enkoder hanya mengirimkan informasi yang terbatas yang tentang sebuah frame untuk menurunkan kapasitas bit transmisi. Selanjutnya, dekoder akan mendekodekan frame video dengan membangkitkan SI, yaitu skema estimasi dan kompensi gerak menggunakan hanya frame-frame yang telah didekodekan sebelumnya di dekoder sebagai frame referensi. Semakin akurat SI yang dihasilkan, maka semakin baik kinerja </span><span class="font25" style="font-style:italic;">rate-distortion</span><span class="font25"> (RD) codec WZVC.</span></p>
<p><span class="font25">Sebagai usaha untuk merealisasikan sebuah codec WZVC praktikal beberapa kelompok peneliti telah mengajukan berapa rancangan codec WZVC. Codec pertama diusulkan [3][4][5] dan dikenal sebagai codec (</span><span class="font25" style="font-style:italic;">coder dekoder</span><span class="font25">) WZVC Stanford. Codec ini menerapkan teknik motion compensation interpolation/extrapolation (MCI/E) untuk membangkitkan SI, menggunakan dua frame referensi di dekoder. Codec ini tidak sepenuhnya praktikal, karena menggunakan frame referensi yang disediakan langsung di dekoder.</span></p>
<p><span class="font25">Untuk meningkatkan kinerja RD codec WZVC, beberapa codec WZVC telah diusulkan dalam literature seperti codec DISCOVER [6] dan WZVC-EM [7]. Kedua codec menggunakan kerangka kerja codec WZVC Stanford, tetapi dengan metode pembangkitan SI yang berbeda. </span><span class="font24">Codec DISCOVER menerapkan metode </span><span class="font25" style="font-style:italic;">Bidirectional Motion-Compensated Frame Interpolation</span><span class="font25"> (B-MCFI), dimana sebuah frame SI diperoleh dengan estimasi dan kompensasi gerak dua frame referensi yang tersedia di dekoder. Sedangkan codec WZVC-EM menerapkan metode</span></p>
<p><span class="font25">pembelajaran medan gerak secara iteratif berbasis pada algoritma Expectation-Maxization (EM). Metode ini akan memperbaharui medan gerak secara iteratif untuk meningkatkan akurasi soft SI.</span></p>
<p><span class="font25">Perbedaan metode SI yang digunakan untuk mendesain codec WZVC menunjukan bahwa parameter utama untuk meningkatkan kinerja codec WZVC adalah bagaimana mendapatkan sebuah metode pembangkitan SI yang efisien. Oleh karena itu, paper ini akan mengevaluasi lebih lanjut penerapan metode pembakitan SI ini dengan membandingkan kinerja RD kedua codec pada ukuran GOP yang berbeda. Sampai saat ini belum ada literatur yang mengkaji evaluasi kinerja RD kedua codec tersebut. Sasarannya adalah akan diperoleh sebuah kerangka kerja codec WZVC yang efisien untuk dikembangkan lebih lanjut.</span></p>
<p><span class="font25">Selanjutnya, paper in diorganisasikan sebagai berikut: Bab 2 menjelaskan tentang </span><span class="font25" style="font-style:italic;">state of the art</span><span class="font25"> codec WZVC, Bab 3 menjelaskan tentang pembangkitan SI pada codec WZVC DISCOVER dan WZVC-EM, Bab 4 membahas tentang Kinerja RD kedua codec tersebut, dan akhirnya Bab 5 adalah kesimpulan dari paper ini.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font25">II. &nbsp;&nbsp;</span><span class="font25" style="font-style:italic;">S</span><span class="font23" style="font-style:italic;">TATE OF THE ART </span><span class="font23" style="font-variant:small-caps;">wzvc</span></p>
<ul style="list-style:none;">
<li>
<p><span class="font25">2.1 &nbsp;&nbsp;&nbsp;Pengkodean Sumber Terdistribusi</span></p></li></ul></li></ul>
<p><span class="font25">Teori pengkodean sumber terdistribusi ditujukan untuk pengkodean dua atau lebih sekuen random dependen secara terdistribusi. Setiap sumber dienkodekan secara independen dan bitstreamnya dikirim ke dekoder tunggal untuk decoding secara gabungan. untuk mengkompres dua sumber dependen secara statistik, laju enkoding minimum </span><span class="font25" style="font-style:italic;">R</span><span class="font25"> yang dibutuhkan untuk memulihkan kedua sumber tanpa kesalahan di dekoder gabungan, oleh teori informasi Shannon rekonstruksi </span><span class="font25" style="font-style:italic;">lossless </span><span class="font25">dari </span><span class="font25" style="font-style:italic;">X</span><span class="font25"> dan </span><span class="font25" style="font-style:italic;">Y</span><span class="font25"> dinyatakan dengan </span><span class="font25" style="font-style:italic;font-variant:small-caps;">R</span><span class="font28" style="font-style:italic;font-variant:small-caps;"><sub>x</sub></span><span class="font6" style="font-style:italic;"> ≥ </span><span class="font25" style="font-style:italic;">H</span><span class="font25">(</span><span class="font25" style="font-style:italic;">X)</span><span class="font25">. Dimana teorema Informasi menegaskan bahwa ketika </span><span class="font25" style="font-style:italic;">R</span><span class="font25"> memenuhi </span><span class="font25" style="font-style:italic;">R </span><span class="font6" style="font-style:italic;">≥ </span><span class="font25" style="font-style:italic;font-variant:small-caps;">R</span><span class="font28" style="font-style:italic;font-variant:small-caps;"><sub>x</sub></span><span class="font25"> + </span><span class="font25" style="font-style:italic;font-variant:small-caps;">R</span><span class="font28" style="font-style:italic;font-variant:small-caps;"><sub>y </sub></span><span class="font6" style="font-style:italic;">≥ </span><span class="font25" style="font-style:italic;">H</span><span class="font25">(</span><span class="font25" style="font-style:italic;">X</span><span class="font25">, </span><span class="font25" style="font-style:italic;">Y</span><span class="font25">), </span><span class="font25" style="font-style:italic;">X</span><span class="font25"> dan </span><span class="font25" style="font-style:italic;">Y</span><span class="font25"> dapat direkonstruksi dengan akurat di dekoder, selama kedua sumber tersebut saling berkorelasi dan laju bit total </span><span class="font25" style="font-style:italic;">R</span><span class="font25"> lebih besar dari entropy gabungan </span><span class="font25" style="font-style:italic;">H</span><span class="font25">(</span><span class="font25" style="font-style:italic;">X</span><span class="font25">,</span><span class="font25" style="font-style:italic;">Y</span><span class="font25">). Sebuah pertanyaan muncul apakah memungkinkan untuk memulihkan dua sekuen dependen ini dengan probabilitas kesalahan rekonstruksi kecil menggunakan laju bit </span><span class="font25" style="font-style:italic;">R</span><span class="font22" style="font-style:italic;">X</span><span class="font25"> &lt;&nbsp;</span><span class="font25" style="font-style:italic;">H</span><span class="font25">(</span><span class="font25" style="font-style:italic;">X</span><span class="font25">) atau </span><span class="font25" style="font-style:italic;">R</span><span class="font22" style="font-style:italic;">Y</span><span class="font25"> &lt;&nbsp;</span><span class="font25" style="font-style:italic;">H</span><span class="font25">(</span><span class="font25" style="font-style:italic;">Y</span><span class="font25">).</span></p><img src="https://jurnal.harianregional.com/media/7245-1.jpg" alt="" style="width:203pt;height:74pt;">
<p><span class="font23">Gambar 1 Skema enkoding independen dan dekoding gabungan untuk dua sumber [1]</span></p>
<p><span class="font25">Slepian dan Wolf [1] telah mempelajari persoalan pada Gambar 1 dan ini merupakan studi pertama tentang Pengkodean Sumber Terdistribusi. Kombinasi laju bit yang</span></p>
<p><span class="font25">mungkin dari </span><span class="font25" style="font-style:italic;">R</span><span class="font22" style="font-style:italic;"><sub>X</sub></span><span class="font25"> dan </span><span class="font25" style="font-style:italic;">R</span><span class="font22" style="font-style:italic;"><sub>Y</sub></span><span class="font25"> untuk merekonstruksi </span><span class="font25" style="font-style:italic;">X</span><span class="font25"> dan </span><span class="font25" style="font-style:italic;">Y </span><span class="font25">dengan probabilitas error kecil, dinyatakan dengan:</span></p>
<p><span class="font23" style="font-style:italic;">R</span><span class="font20" style="font-style:italic;">χ </span><span class="font4" style="font-style:italic;">≥ </span><span class="font23" style="font-style:italic;">H</span><span class="font28"> ( </span><span class="font23" style="font-style:italic;">XY</span><span class="font28">)</span></p>
<div>
<p><span class="font23">(1)</span></p>
</div><br clear="all">
<p><span class="font22" style="font-style:italic;">R</span><span class="font19" style="font-style:italic;">Y</span><span class="font3"> ≥ </span><span class="font22" style="font-style:italic;">H</span><span class="font6" style="font-style:italic;">(</span><span class="font22" style="font-style:italic;">YX</span><span class="font6">)</span></p>
<p><span class="font22" style="font-style:italic;">R</span><span class="font19" style="font-style:italic;">χ</span><span class="font3"> + </span><span class="font22" style="font-style:italic;">R</span><span class="font19" style="font-style:italic;">Y</span><span class="font3"> ≥ </span><span class="font22" style="font-style:italic;">H</span><span class="font25"> (</span><span class="font22" style="font-style:italic;">X</span><span class="font22">, </span><span class="font22" style="font-style:italic;">Y</span><span class="font25">)</span></p>
<div>
<p><span class="font23">(2)</span></p>
<p><span class="font23">(3)</span></p>
</div><br clear="all">
<p><span class="font25">Konsep pengkodean Wyner-Ziv (WZ) [1] sangat cocok diterapkan pada aplikasi pengkodean video. Dalam literatur pengkodean video dikenal sebagai </span><span class="font25" style="font-style:italic;">Wyner-Ziv Video Coding </span><span class="font25">(WZVC). Dalam kasus ini, beberapa frame sekuen video dienkodekan Wyner-Ziv, sedangkan frame sisa dienkodekan menggunakan standar pengkodean citra/video tradisional seperti JPEG atau H.264. Dekoder, dengan menggunakan frame-frame yang dikodekan secara tradisional kemudian membangkitkan estimasi frame sekarang melalui teknik interpolasi/ektrapolasi frame. Frame ini yang kemudian digunakan dalam proses dekoding frame WZ sekarang (dienkodekan WZ).</span></p>
<p><span class="font25">Teorema SW [1] dan WZ [2] yang sudah sangat dikenal, dalam Teori Informasi menegaskan bahwa adalah mungkin untuk mengkompres dua sinyal dependen secara statistik dengan cara terdistribusi (enkoding terpisah, dekoding gabungan) menggunakan laju bit yang serupa seperti yang digunakan dalam sistem di mana sinyal dienkodekan dan didekodekan secara bersama-sama (gabungan), seperti pada pengkodean sumber tradisional (gambar 1).</span></p>
<p><span class="font25">Wyner dan Ziv [2] telah mempelajari kasus khusus pada pengkodean SW yang berkaitan dengan laju bit di koordinat (</span><span class="font25" style="font-style:italic;">H</span><span class="font25">(</span><span class="font25" style="font-style:italic;">X</span><span class="font25">|</span><span class="font25" style="font-style:italic;">Y</span><span class="font25">), </span><span class="font25" style="font-style:italic;">H</span><span class="font25">(</span><span class="font25" style="font-style:italic;">Y</span><span class="font25">)), di Gambar 2. Kasus khusus ini berkaitan dengan pengkodean sumber sekuen </span><span class="font25" style="font-style:italic;">X</span><span class="font25"> dengan mempertimbangkan sekuen </span><span class="font25" style="font-style:italic;">Y</span><span class="font25">, dikenal sebagai </span><span class="font25" style="font-style:italic;">side information</span><span class="font25"> (SI), tersedia di dekoder (Gambar 2) dalam banyak literatur dikenal sebagai kompresi lossy dengan dekoder SI. Disebut kompresi lossy karena Wyner dan Ziv mempertimbangkan distorsi (</span><span class="font25" style="font-style:italic;">D</span><span class="font25">) rata-rata yang dapat diterima, diantara sekuen </span><span class="font25" style="font-style:italic;">X</span><span class="font25"> dan versi dekodenya (</span><span class="font25" style="font-style:italic;">X’</span><span class="font25">).</span></p><img src="https://jurnal.harianregional.com/media/7245-2.jpg" alt="" style="width:221pt;height:79pt;">
<p><span class="font23">Gambar 2 Kompresi </span><span class="font23" style="font-style:italic;">lossy</span><span class="font23"> dengan </span><span class="font23" style="font-style:italic;">side information</span><span class="font23"> [2]</span></p>
<p><span class="font25">Pada Gambar 2 dapat dilihat dimana </span><span class="font25" style="font-style:italic;">X</span><span class="font25"> adalah sekuen yang akan dienkodekan sehingga disebut sebagai informasi utama, dan </span><span class="font25" style="font-style:italic;">Y</span><span class="font25"> disebut </span><span class="font25" style="font-style:italic;">side information</span><span class="font25"> adalah dianggap tersedia di dekoder.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font25">2.2 &nbsp;&nbsp;&nbsp;Codec WZVC </span><span class="font25" style="font-style:italic;">Domain Transform</span></p></li></ul>
<p><span class="font25">Berdasarkan pengkodean sumber terdistribusi, sebuah codec WZVC praktikal domain transform pertama kali dikembangkan di Stanford University [5]. Solusi pengkodean ini dikenal dengan </span><span class="font25" style="font-style:italic;">Wyner-Ziv video Coding</span><span class="font25"> (WZVC) Stanford.</span></p>
<div><img src="https://jurnal.harianregional.com/media/7245-3.jpg" alt="" style="width:239pt;height:147pt;">
<p><span class="font23">Gambar 3 Arsidektur WZVC Stanford [5]</span></p>
</div><br clear="all">
<p><span class="font25">Seperti ditunjukan pada Gambar 3, codec WZVC Stanford pada prosedur encoding frame WZ di domain transform dilakukan dengan mentransformasi DCT dan kuantisasi frame WZ. Teknik pengkodean kanal Turbo code diterapkan untuk pembangkitan bit parity dari bitplane indek kuantisasi. Bit parity ini nantinya akan dikirim ke dekoder secara bertahap untuk memperbaiki error dalam SI. Dimana control laju dibentuk di dekoder dengan saluran umpan balik, dekoder meminta kembali bit parity jika prosedur dekoding tidak berhasil mengestimasi frame WZ.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font25">III.</span><span class="font25" style="font-style:italic;"> &nbsp;&nbsp;&nbsp;P</span><span class="font23" style="font-style:italic;">EMBANGKITAN </span><span class="font23" style="font-variant:small-caps;">side information pada codec</span><span class="font25"> WZVC</span></p></li></ul>
<p><span class="font25">Sebagai usaha meningkatkan kinerja RD codec WZVC Stanford, beberapa desain codec WZVC baru telah diusulkan, dengan fokus utama perbaikan pada metode pembangkitan SI. codec DISCOVER [6] menerapkan teknik B-MCFI dan WZVC-EM [7]. metode pembelajaran tanpa supervisi medan gerak berbasis pada algoritma EM. Detail algoritma pembangkitan SI di kedua codec tersebut dijeaskan pada subbab berikut.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font25">3.1 &nbsp;&nbsp;&nbsp;WZVC DISCOVER</span></p></li></ul>
<p><span class="font25">Pada codec WZVC DISCOVER, pembangkitan SI menggunakan metode </span><span class="font25" style="font-style:italic;">bidirectional motion-compensated frame interpolation</span><span class="font25"> (B-MCFI) berbasis blok yang dikembangkan oleh [8]. Metode menggunakan dua frame referensi yaitu satu frame temporal sebelumnya (</span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;"><sub>B</sub></span><span class="font25">) dan frame temporal berikutnya (</span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;">F</span><span class="font25">).</span></p>
<div><img src="https://jurnal.harianregional.com/media/7245-4.jpg" alt="" style="width:264pt;height:109pt;">
<p><span class="font23">fM∏Mek 7h4∏ul</span></p>
<p><span class="font1" style="font-weight:bold;">Irtra Decoder</span></p>
<p><span class="font1" style="font-weight:bold;">⅛2M∕ΛVC</span></p>
<p><span class="font1" style="font-weight:bold;">Intra Lncixler</span></p>
<p><span class="font1" style="font-weight:bold;text-decoration:underline;">X » Kι'y l ri∏⅜&lt;</span></p>
<p><span class="font23">Gambar 4 Arsidektur codec WZVC DISCOVER [9]</span></p>
</div><br clear="all">
<div><img src="https://jurnal.harianregional.com/media/7245-5.png" alt="" style="width:248pt;height:44pt;">
<p><span class="font23">Gambar 5 Kerangka kerja interpolasi frame untuk pembuatan SI [10]</span></p>
</div><br clear="all">
<p><span class="font25">Kerangka kerja interpolasi frame untuk pembangkitan SI seperti yang ditunjukkan pada gambar diatas dapat dijelaskan sebagai berikut [10]:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font26">•</span><span class="font25"> &nbsp;&nbsp;&nbsp;Algoritma </span><span class="font25" style="font-style:italic;">Forward Motion Estimation</span></p></li></ul>
<p><span class="font25">Algoritma pencocokan blok digunakan untuk mengestimasi medan gerak antara frame </span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;"><sub>B</sub></span><span class="font25"> dan frame </span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;"><sub>F </sub></span><span class="font25">dimana jumlah vektor gerak, kedua frame </span><span class="font25" style="font-style:italic;">X </span><span class="font22" style="font-style:italic;">B</span><span class="font25"> dan </span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;">F</span><span class="font25"> akan di </span><span class="font25" style="font-style:italic;">low pass filter</span><span class="font25"> (LPF) terlebih dahulu sebelum dicocokkan. Algoritma </span><span class="font25" style="font-style:italic;">Forward Motion Estimation</span><span class="font25"> (FME) menggunakan kriteria matching </span><span class="font25" style="font-style:italic;">mean absolute difference</span><span class="font25"> (MAD) berdasarkan pada </span><span class="font25" style="font-style:italic;">cost function</span><span class="font25"> (CF) minimal dan dinyatakan sebagai [10]:</span></p>
<p><span class="font7">(</span><span class="font22" style="font-style:italic;">V</span><span class="font19" style="font-style:italic;">χ</span><span class="font22">, </span><span class="font22" style="font-style:italic;">V</span><span class="font19" style="font-style:italic;">y</span><span class="font7"> ) </span><span class="font3">= </span><span class="font22">argmin </span><span class="font22" style="font-style:italic;">CF</span><span class="font7"> (</span><span class="font22" style="font-style:italic;">d</span><span class="font19" style="font-style:italic;">χ</span><span class="font22">, </span><span class="font22" style="font-style:italic;">d</span><span class="font19" style="font-style:italic;">y</span><span class="font7">) </span><span class="font22">; </span><span class="font22" style="font-style:italic;">d</span><span class="font19" style="font-style:italic;">χ</span><span class="font3"> = </span><span class="font6">[</span><span class="font3">-</span><span class="font22" style="font-style:italic;">M</span><span class="font22">, </span><span class="font22" style="font-style:italic;">M</span><span class="font6"> ]</span><span class="font22">; </span><span class="font22" style="font-style:italic;">d</span><span class="font19" style="font-style:italic;">y</span><span class="font3"> = </span><span class="font6">[</span><span class="font3">-</span><span class="font22" style="font-style:italic;">M</span><span class="font22">, </span><span class="font22" style="font-style:italic;">M</span><span class="font6"> ] </span><span class="font19" style="font-style:italic;">d<sub>x</sub></span><span class="font19">,</span><span class="font19" style="font-style:italic;">d<sub>y</sub></span></p>
<p><span class="font23" style="font-style:italic;">MAD</span><span class="font15"> ( </span><span class="font23" style="font-style:italic;">d</span><span class="font20" style="font-style:italic;">χ</span><span class="font23"><sup>,</sup> </span><span class="font23" style="font-style:italic;">d</span><span class="font20" style="font-style:italic;">y</span><span class="font15"> ) </span><span class="font4">= </span><span class="font27">-1 </span><span class="font8">∑ </span><span class="font23" style="font-style:italic;">X</span><span class="font20" style="font-style:italic;">F</span><span class="font27"> ( </span><span class="font23" style="font-style:italic;">x</span><span class="font23"><sup>,</sup> </span><span class="font23" style="font-style:italic;">y</span><span class="font27">)<sup>-</sup></span><span class="font23" style="font-style:italic;">X</span><span class="font20" style="font-style:italic;">B</span><span class="font15"> ( </span><span class="font23" style="font-style:italic;"><sup>χ</sup></span><span class="font4"> + </span><span class="font23" style="font-style:italic;">d</span><span class="font20" style="font-style:italic;">χ</span><span class="font23"><sup>,</sup> </span><span class="font23" style="font-style:italic;">y</span><span class="font4"> + </span><span class="font23" style="font-style:italic;">d</span><span class="font20" style="font-style:italic;">y</span><span class="font15"> )∣ </span><span class="font23" style="font-style:italic;">N</span><span class="font2"> (</span><span class="font20" style="font-style:italic;">x</span><span class="font20">,</span><span class="font20" style="font-style:italic;">y</span><span class="font2">)</span><span class="font13">∈</span><span class="font20" style="font-style:italic;">B</span></p>
<ul style="list-style:none;"><li>
<p><span class="font26">•</span><span class="font25" style="font-style:italic;"> &nbsp;&nbsp;&nbsp;Bidirectional Motion Estimation</span><span class="font25"> (BME)</span></p></li></ul>
<p><span class="font25">Algoritma BME diterapkan untuk memperbaiki</span></p>
<div>
<p><span class="font25">(4)</span></p>
<p><span class="font25">(5)</span></p>
<p><span class="font25">vektor-</span></p>
</div><br clear="all">
<p><span class="font25">vektor gerak pada blok sekarang di frame interpolasi </span><span class="font25" style="font-style:italic;">Y </span><span class="font25">sebelumnya dan berhubungan dengan blok-blok tetangga terdekatnya yang telah diperoleh pada prosedur FME dan dirumuskan sebagai berikut[10]:</span></p>
<p><span class="font7">(</span><span class="font24" style="font-style:italic;">x</span><span class="font20">ι</span><span class="font24"><sup>,</sup> </span><span class="font24" style="font-style:italic;">y</span><span class="font20">ι </span><span class="font7">) </span><span class="font5">= </span><span class="font7">( </span><span class="font24" style="font-style:italic;">x</span><span class="font20" style="font-style:italic;">i<sup>,</sup> </span><span class="font24" style="font-style:italic;">y<sub>i</sub></span><span class="font7">)<sup>+</sup></span><span class="font24" style="font-style:italic;">MV</span><span class="font7"> (</span><span class="font24" style="font-style:italic;">B</span><span class="font20">i</span><span class="font7">) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font25"><sup>(6)</sup></span></p>
<p><span class="font7">(</span><span class="font24" style="font-style:italic;">x</span><span class="font20">2</span><span class="font24"><sup>,</sup> </span><span class="font24" style="font-style:italic;">y</span><span class="font20"> 2 </span><span class="font7">)</span><span class="font5">=</span><span class="font7">( </span><span class="font24" style="font-style:italic;"><sup>x</sup></span><span class="font20" style="font-style:italic;">i</span><span class="font24" style="font-style:italic;"><sup>,</sup> y<sub>i</sub></span><span class="font7" style="font-style:italic;">)</span><span class="font5" style="font-style:italic;">-</span><span class="font24" style="font-style:italic;">MV</span><span class="font7"> (</span><span class="font24" style="font-style:italic;">B</span><span class="font20">i</span><span class="font7">) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font25"><sup>(7)</sup></span></p>
<ul style="list-style:none;"><li>
<p><span class="font26">•</span><span class="font25" style="font-style:italic;"> &nbsp;&nbsp;&nbsp;Spatial Motion Smoothing</span></p></li></ul>
<p><span class="font25">Algoritma </span><span class="font25" style="font-style:italic;">spatial motion smoothing</span><span class="font25"> diterapkan untuk menurunkan jumlah vektor gerak yang salah dengan membandingkan motion vektor yang salah dengan medan gerak yang sebenarnya pada codec DISCOVER menggunakan </span><span class="font25" style="font-style:italic;">weighted median vector filter</span><span class="font25"> dengan formula sebagai berikut[10]:</span></p>
<p><span class="font21" style="font-style:italic;">NN</span></p>
<p><span class="font31">Σ </span><span class="font25" style="font-style:italic;"><sup>w</sup></span><span class="font21" style="font-style:italic;">j Ixwvmf</span><span class="font6"> <sup>-</sup> </span><span class="font25" style="font-style:italic;">x</span><span class="font21" style="font-style:italic;">jl</span><span class="font6"> ≤</span><span class="font31">Σ </span><span class="font25" style="font-style:italic;">w</span><span class="font21" style="font-style:italic;">j</span><span class="font6">l</span><span class="font25" style="font-style:italic;">x</span><span class="font21" style="font-style:italic;">,</span><span class="font6"><sup>-</sup> </span><span class="font25" style="font-style:italic;">j (<sup>8</sup>) </span><span class="font21" style="font-style:italic;">j</span><span class="font2">=</span><span class="font21">1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font21" style="font-style:italic;">j</span><span class="font2">=</span><span class="font21">1</span></p>
<p><span class="font25">Pemilihan bobot dibentuk selaras dengan error dinyatakan sebagai:</span></p>
<p><span class="font4">= </span><span class="font23" style="font-style:italic;">MSE</span><span class="font6"> ( </span><span class="font23" style="font-style:italic;">x<sub>c</sub></span><span class="font23">, </span><span class="font23" style="font-style:italic;">B</span><span class="font6">)</span></p>
<p><span class="font20" style="font-style:italic;"><sup>j</sup></span><span class="font4"> = </span><span class="font23" style="font-style:italic;">MSE</span><span class="font8"> ( </span><span class="font23" style="font-style:italic;">x<sub>j</sub></span><span class="font23">, </span><span class="font23" style="font-style:italic;">B</span><span class="font8">)</span></p>
<div>
<p><span class="font25">prediksi,</span></p>
</div><br clear="all">
<div>
<p><span class="font25">(9)</span></p>
</div><br clear="all">
<p><span class="font25" style="font-style:italic;">Mean square error</span><span class="font25"> (MSE) menyatakan </span><span class="font25" style="font-style:italic;">matching</span><span class="font25"> yang telah berhasil antara blok sekarang B di frame </span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;">F</span><span class="font25"> dan blok di frame</span></p>
<p><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;"><sub>B</sub></span><span class="font25"> yang dikompensasi dengan vektor </span><span class="font25" style="font-style:italic;">x</span><span class="font22" style="font-style:italic;"><sub>c</sub></span><span class="font25"> dan </span><span class="font25" style="font-style:italic;">x</span><span class="font22" style="font-style:italic;">j<sub>.</sub></span><span class="font25"> Pada area sekitar hidung terdapat kesalahan interpolasi medan gerak, karena vektor-vektor gerak hanya meminimalkan MSE antara frame-frame Key tetapi tidak menyatakan medan gerak yang sebenarnya. Kesalahan interpolasi medan gerak pada Gambar selanjutnya dihaluskan dengan weighted vector median filter menggunakan vektor-vektor gerak tetangga sebagai faktor bobot.</span></p>
<div><img src="https://jurnal.harianregional.com/media/7245-6.jpg" alt="" style="width:197pt;height:81pt;">
<p><span class="font23">Gambar 6 Frame #7 dari sekuen video Foreman (a) dengan (b) tanpa </span><span class="font23" style="font-style:italic;">spatial motion smoothing</span><span class="font23"> [11]</span></p>
</div><br clear="all">
<ul style="list-style:none;"><li>
<p><span class="font26">•</span><span class="font25" style="font-style:italic;"> &nbsp;&nbsp;&nbsp;Bidirectional Motion Compensation</span></p></li></ul>
<p><span class="font25">Setelah vektor-vektor akhir telah diperoleh, frame interpolasi Y dibentuk dengan bidirectional motion comensation. Diasumsikan bahwa interval waktu antara frame Key XB dengan frame interpolasi Y adalah sama dengan interval waktu antara frame interpolasi Y dengan frame Key XF, sehingga setiap frame Key memiliki bobot yang sama (1/2), ketika estimasi gerak dibentuk .</span></p>
<ul style="list-style:none;"><li>
<p><span class="font25">3.2 Codec WZVC-EM</span></p></li></ul>
<p><span class="font25">Varodayan dkk [12] mengajukan desain codec WZVC dengan skema pembangkitan SI menggunakan metode pembelajaran medan gerak tanpa supervisi berbasis algoritma EM, dan dikenal sebagai codec WZVC-EM. Seperti ditunjukan pada Gambar 7, untuk mengkodekan frame WZ, dekoder membentuk skema pembelajaran gerak tanpa supervisi (</span><span class="font25" style="font-style:italic;">unsupervised</span><span class="font25">) menggunakan </span><span class="font25" style="font-style:italic;">bitstream</span><span class="font25"> frame WZ secara langsung dan satu frame SI yang sudah didekodekan sebelumnya. Medan gerak yang dihasilkan selanjutnya digunakan untuk membangkitan soft SI. Detail kerangka kerja codec WZVC-EM dapat dijelaskan sebagai berikut :</span></p><img src="https://jurnal.harianregional.com/media/7245-7.jpg" alt="" style="width:244pt;height:150pt;">
<p><span class="font23">Gambar 7 Arsidektur codec WZVC berbasis EM domain transform [12]</span></p>
<ul style="list-style:none;"><li>
<p><span class="font6" style="font-style:italic;">•</span><span class="font25"> &nbsp;&nbsp;&nbsp;Pada enkoder, frame </span><span class="font25" style="font-style:italic;">Key</span><span class="font25"> (</span><span class="font25" style="font-style:italic;">Y</span><span class="font25"> di kodekan dan ditransmisikan dengan pengkodean konvensional JPEG. Enkoding frame WZ (</span><span class="font25" style="font-style:italic;">X</span><span class="font25">) dilakukan secara independen dari frame </span><span class="font25" style="font-style:italic;">Y</span><span class="font25">. Enkoder Wyner-Ziv mentransformasi frame </span><span class="font25" style="font-style:italic;">X</span><span class="font25"> ke dalam koefisien </span><span class="font25" style="font-style:italic;">DCT</span><span class="font25"> berbasis blok </span><span class="font25" style="font-style:italic;">k</span><span class="font26"> × </span><span class="font25" style="font-style:italic;">k</span><span class="font25"> (</span><span class="font25" style="font-style:italic;">X</span><span class="font25">), dimana </span><span class="font25" style="font-style:italic;">k </span><span class="font25">adalah juga ukuran pencocokan blok pada estimator gerak. Koefisien-koefisien transform (</span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;"><sup>T</sup></span><span class="font25">) kemudian dikuantisasi menjadi indek-indek kuantisasi (</span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;"><sup>TQ</sup></span><span class="font25">), menggunakan tabel kuantisasi rekomendasi JPEG. Indek-indek koefisien terkuantisasi </span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;"><sup>TQ</sup></span><span class="font25"> dikomunikasikan ke dekoder menggunakan LDPC </span><span class="font25" style="font-style:italic;">code</span><span class="font25"> [12]</span><span class="font25" style="font-style:italic;">.</span></p></li>
<li>
<p><span class="font26">•</span><span class="font25"> &nbsp;&nbsp;&nbsp;Pada sisi dekoder, piksel-piksel dari </span><span class="font25" style="font-style:italic;">Y</span><span class="font25"> tidak digunakan secara langsung karena sistem </span><span class="font25" style="font-style:italic;">lossless</span><span class="font25"> bekerja dalam domain transform. Oleh karenanya, </span><span class="font25" style="font-style:italic;">Y</span><span class="font25"> di DCT berbasis blok </span><span class="font25" style="font-style:italic;">k x k</span><span class="font25">, yang menghitung transform seluruh blok </span><span class="font25" style="font-style:italic;">k x k</span><span class="font25"> di seluruh pergeseran piksel. Dengan cara ini, koefisien-koefisien transform dari setiap kandidat gerak dari </span><span class="font25" style="font-style:italic;">Y</span><span class="font25"> tersedia di : estimator gerak dan model probabilitas, untuk memperoleh </span><span class="font25" style="font-style:italic;">soft</span><span class="font25"> SI (</span><span class="font26" style="font-style:italic;">ψ</span><span class="font25">). Akhirnya, indek-indek koefisien kuantisasi dari </span><span class="font25" style="font-style:italic;">X</span><span class="font25">, dipulihkan dari sistem </span><span class="font25" style="font-style:italic;">lossless</span><span class="font25">, direkonstruksi di pusat </span><span class="font25" style="font-style:italic;">binbin</span><span class="font25"> kuantisasinya (</span><span class="font25" style="font-style:italic;">centroid reconstruction</span><span class="font25">) dan ditransformasi balik untuk menghasilkan frame rekonstruksi </span><span class="font24" style="font-style:italic;">X </span><span class="font25">.</span></p></li></ul>
<p><span class="font25">Pada gambar 7, bagian yang diarsir adalah bagian penerapan algoritma EM dalam codec WZVC-EM dan secara detail dijelaskan sebagai berikut:</span></p>
<ul style="list-style:none;"><li>
<p><span class="font26">•</span><span class="font25"> &nbsp;&nbsp;&nbsp;Model</span></p></li></ul>
<p><span class="font25">Menurut [7] : model distribusi probabilitas posterior dekoder dari sumber </span><span class="font25" style="font-style:italic;">X</span><span class="font25"> berbasis pada parameter </span><span class="font25" style="font-style:italic;">soft estimate</span><span class="font25"> dekoder LDPC </span><span class="font26" style="font-style:italic;">θ</span><span class="font25"> untuk menghitung distribusi probabilitas posteriori dari M adalah:</span></p>
<p><span class="font23" style="font-style:italic;">P</span><span class="font20" style="font-style:italic;">app</span><span class="font27"> {</span><span class="font23" style="font-style:italic;">M</span><span class="font27"> }</span><span class="font4">≡ </span><span class="font23" style="font-style:italic;">P</span><span class="font27"> {</span><span class="font23" style="font-style:italic;">M </span><span class="font17" style="font-style:italic;font-variant:small-caps;">∣</span><span class="font26" style="font-style:italic;font-variant:small-caps;">y</span><span class="font24">, </span><span class="font23" style="font-style:italic;">S</span><span class="font24">; </span><span class="font4" style="font-style:italic;">θ</span><span class="font27">}</span></p>
<p><span class="font4">∞ </span><span class="font23" style="font-style:italic;">P</span><span class="font27">{</span><span class="font23" style="font-style:italic;">M</span><span class="font27">}</span><span class="font23" style="font-style:italic;">P</span><span class="font8" style="font-style:italic;">{</span><span class="font23" style="font-style:italic;">Y</span><span class="font24">,</span><span class="font23" style="font-style:italic;">SM</span><span class="font24">;</span><span class="font4" style="font-style:italic;">θ</span><span class="font8">}</span></p>
<div>
<p><span class="font25">(12)</span></p>
</div><br clear="all">
<p><span class="font25">dengan step kedua hukum Bayes. Bentuk ini menegaskan sebuah bentuk solusi iteratif EM.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font26">•</span><span class="font25"> &nbsp;&nbsp;&nbsp;Algoritma E-step</span></p></li></ul>
<p><span class="font25">E-step memperbaharui distribusi </span><span class="font25" style="font-style:italic;">M</span><span class="font25"> yang telah diestimasi dengan mengacu parameter </span><span class="font25" style="font-style:italic;">θ</span><span class="font25">. Secara sedehana estimasi </span><span class="font25" style="font-style:italic;">M </span><span class="font25">dilakukan di vektor gerak berbasis blok </span><span class="font25" style="font-style:italic;">M</span><span class="font22" style="font-style:italic;">(<sub>u,v</sub>)</span><span class="font25"> dan S diabaikan. Pada ukuran blok </span><span class="font25" style="font-style:italic;">k</span><span class="font25">, setiap blok </span><span class="font25" style="font-style:italic;">k-</span><span class="font26">×</span><span class="font25" style="font-style:italic;">-k</span><span class="font25"> dari </span><span class="font25" style="font-style:italic;">θ</span><span class="font22" style="font-style:italic;">(t<sup>1</sup></span><span class="font25"> dibandingkan dengan setiap </span><span class="font25" style="font-style:italic;">Y</span><span class="font25">, pada blok </span><span class="font25" style="font-style:italic;">co-located</span><span class="font25"> dan sekitarnya pada range pencarian gerak tetap. Untuk sebuah blok </span><span class="font25" style="font-style:italic;">θ</span><span class="font22" style="font-style:italic;">(<sub>u,v</sub>)</span><span class="font22"><sup>(</sup></span><span class="font22" style="font-style:italic;"><sup>t-1</sup></span><span class="font22"><sup>) </sup></span><span class="font25">dengan piksel kiri atas dilokasikan di (</span><span class="font25" style="font-style:italic;">u,v</span><span class="font25">), distribusi pada pergeseran </span><span class="font25" style="font-style:italic;">M</span><span class="font22" style="font-style:italic;">(<sub>u,v</sub>)</span><span class="font25"> diperbaharui dan dinormalisasikan [7]:</span></p>
<p><span class="font25" style="font-style:italic;">P</span><span class="font1" style="font-style:italic;">p</span><span class="font10"> { </span><span class="font25" style="font-style:italic;">M</span><span class="font1" style="font-style:italic;">u</span><span class="font1" style="font-weight:bold;">, </span><span class="font1" style="font-style:italic;">v</span><span class="font10"> } </span><span class="font25">:</span><span class="font6">= </span><span class="font25" style="font-style:italic;">^ { M</span><span class="font1" style="font-style:italic;">u</span><span class="font1" style="font-weight:bold;">, </span><span class="font1" style="font-style:italic;">v</span><span class="font10"> } </span><span class="font25" style="font-style:italic;"><sup>P</sup> </span><span class="font32" style="font-style:italic;">{</span><span class="font25" style="font-style:italic;">Y </span><span class="font1" style="font-style:italic;">u</span><span class="font1" style="font-weight:bold;">, </span><span class="font1" style="font-style:italic;">v</span><span class="font3">)<sub>+</sub> </span><span class="font1" style="font-style:italic;">M</span><span class="font19" style="font-style:italic;">uv</span><span class="font25"> I</span><span class="font25" style="font-style:italic;">M</span><span class="font1" style="font-style:italic;">u</span><span class="font1" style="font-weight:bold;">, </span><span class="font1" style="font-style:italic;">v</span><span class="font25"> ; </span><span class="font3">C’</span><span class="font12">} </span><span class="font25"><sup>(13)</sup></span></p>
<p><span class="font25">dimana </span><span class="font25" style="font-style:italic;">Y</span><span class="font22">(</span><span class="font22" style="font-style:italic;"><sub>u</sub>,v)<sub>+</sub>M<sub>u</sub>,<sub>v</sub></span><span class="font25"> adalah blok </span><span class="font25" style="font-style:italic;">k-</span><span class="font6" style="font-style:italic;">×</span><span class="font25" style="font-style:italic;">-k</span><span class="font25"> dengan piksel kiri atas di ((</span><span class="font25" style="font-style:italic;">u,v)+M</span><span class="font22" style="font-style:italic;"><sub>u</sub>,v</span><span class="font25">) dan </span><span class="font25" style="font-style:italic;">P</span><span class="font25">{</span><span class="font25" style="font-style:italic;">Y</span><span class="font22">(</span><span class="font22" style="font-style:italic;">u,v</span><span class="font22">)</span><span class="font22" style="font-style:italic;">+Muv</span><span class="font25" style="font-style:italic;">|M</span><span class="font22" style="font-style:italic;">u,v</span><span class="font25" style="font-style:italic;">;</span><span class="font26" style="font-style:italic;">θ</span><span class="font22" style="font-style:italic;">u,v</span><span class="font22"><sup>(</sup></span><span class="font22" style="font-style:italic;"><sup>t-1</sup></span><span class="font22"><sup>)</sup></span><span class="font25">} adalah probabilitas pengamatan </span><span class="font25" style="font-style:italic;">Y</span><span class="font22">(</span><span class="font22" style="font-style:italic;"><sub>u</sub>,<sub>v</sub></span><span class="font22">)</span><span class="font22" style="font-style:italic;"><sub>+</sub>M<sub>u</sub>,<sub>v</sub></span><span class="font25"> dimana vektor </span><span class="font25" style="font-style:italic;">M</span><span class="font22" style="font-style:italic;"><sub>u</sub>,<sub>v</sub></span><span class="font25"> dari </span><span class="font25" style="font-style:italic;">X</span><span class="font22" style="font-style:italic;"><sub>u</sub>,<sub>v </sub></span><span class="font25">(diparameterkan oleh </span><span class="font26" style="font-style:italic;">θ</span><span class="font22" style="font-style:italic;">u,v</span><span class="font22"><sup>(</sup></span><span class="font22" style="font-style:italic;"><sup>t-1</sup></span><span class="font22"><sup>)</sup></span><span class="font25">) .</span></p>
<p><span class="font25">Secara umum, probabilitas bahwa pencampuran SI memiliki nilai </span><span class="font25" style="font-style:italic;">ω</span><span class="font25"> di pixel (</span><span class="font25" style="font-style:italic;">i,j</span><span class="font25">) adalah:</span></p>
<p><span class="font24" style="font-style:italic;">ψ</span><span class="font24"><sup>(</sup></span><span class="font24" style="font-style:italic;"><sup>t</sup>\</span><span class="font23" style="font-style:italic;">i</span><span class="font23"><sup>, </sup></span><span class="font23" style="font-style:italic;"><sup>j</sup></span><span class="font23"><sup>, </sup></span><span class="font4" style="font-style:italic;"><sup>ω</sup></span><span class="font6"> ) </span><span class="font4">= </span><span class="font7">∑ </span><span class="font23" style="font-style:italic;">P</span><span class="font20" style="font-style:italic;">app </span><span class="font8" style="font-style:italic;">{</span><span class="font23" style="font-style:italic;">M</span><span class="font20" style="font-style:italic;">i </span><span class="font20" style="font-style:italic;font-variant:small-caps;"><sub>j</sub></span><span class="font4"> = </span><span class="font23" style="font-style:italic;">m</span><span class="font8">} </span><span class="font23" style="font-style:italic;">P</span><span class="font11"> {</span><span class="font23" style="font-style:italic;">X</span><span class="font6"> (</span><span class="font23" style="font-style:italic;">i</span><span class="font23"><sup>, </sup></span><span class="font23" style="font-style:italic;"><sup>j</sup></span><span class="font6"> ) </span><span class="font4">= </span><span class="font4" style="font-style:italic;"><sup>ω</sup> </span><span class="font24" style="font-style:italic;">M. </span><span class="font20" style="font-style:italic;">^</span><span class="font4"> = </span><span class="font23" style="font-style:italic;">m</span><span class="font23"><sup>,</sup> </span><span class="font23" style="font-style:italic;">Y</span><span class="font11">} </span><span class="font20" style="font-style:italic;">m</span></p>
<p><span class="font4">= </span><span class="font7">∑ </span><span class="font23" style="font-style:italic;">P</span><span class="font20" style="font-style:italic;">p</span><span class="font8"> {</span><span class="font23" style="font-style:italic;">M</span><span class="font20" style="font-style:italic;">i</span><span class="font20">, </span><span class="font20" style="font-style:italic;"><sub>1</sub></span><span class="font4"> = </span><span class="font23" style="font-style:italic;">m</span><span class="font8" style="font-style:italic;">} </span><span class="font23" style="font-style:italic;">P</span><span class="font20" style="font-style:italic;">z</span><span class="font30"> {</span><span class="font24" style="font-style:italic;">ω </span><span class="font4" style="font-style:italic;">- </span><span class="font23" style="font-style:italic;">Y</span><span class="font6"> (</span><span class="font23" style="font-style:italic;">i</span><span class="font23"><sup>,</sup> </span><span class="font23" style="font-style:italic;">j</span><span class="font6">)</span><span class="font30">} </span><span class="font20" style="font-style:italic;">m</span></p>
<p><span class="font25">(14)</span></p>
<p><span class="font25">dimana </span><span class="font25" style="font-style:italic;">p</span><span class="font22" style="font-style:italic;">Z</span><span class="font25">(</span><span class="font25" style="font-style:italic;">z</span><span class="font25">) adalah </span><span class="font25" style="font-style:italic;">probability mass function</span><span class="font25"> (pmf) dari noise additive independen </span><span class="font25" style="font-style:italic;">Z</span><span class="font25">, dan </span><span class="font25" style="font-style:italic;">Y</span><span class="font22" style="font-style:italic;"><sub>m</sub></span><span class="font25"> adalah frame rekonstruksi sebelumnya terkompensasi pada </span><span class="font25" style="font-style:italic;">m</span><span class="font25"> konfigurasi gerak.</span></p>
<p><span class="font25">Persamaan 14 menunjukan bahwa penjumlahan bobot meliputi seluruh versi pergeseran dari </span><span class="font25" style="font-style:italic;">Y</span><span class="font22" style="font-style:italic;">.</span><span class="font25" style="font-style:italic;">.</span><span class="font25"> Selama seluruh distribusi </span><span class="font25" style="font-style:italic;">M</span><span class="font22">(</span><span class="font22" style="font-style:italic;"><sub>i,</sub>j</span><span class="font22">) </span><span class="font25">diperoleh, maka operasi pencampuran</span></p>
<p><span class="font25">memungkinkan seluruh kandidat dari proses pergeseran berkontribusi secara partial untuk soft SI, </span><span class="font25" style="font-style:italic;">ψ</span><span class="font25">(</span><span class="font25" style="font-style:italic;">i,j</span><span class="font25">).</span></p>
<p><span class="font25">Model blok kandidat ini membatasi ketergantungan statistik (soft matching) antara </span><span class="font25" style="font-style:italic;">x</span><span class="font25">[</span><span class="font25" style="font-style:italic;">i</span><span class="font25">] dan </span><span class="font25" style="font-style:italic;">Ŷ</span><span class="font22" style="font-style:italic;">(u,v)</span><span class="font25">[</span><span class="font25" style="font-style:italic;">i,m</span><span class="font22" style="font-style:italic;">i</span><span class="font25">] dengan parameter Laplacian (</span><span class="font26" style="font-style:italic;">σ</span><span class="font25">), sehingga :</span></p>
<h2><a name="bookmark2"></a><span class="font26" style="font-style:italic;"><a name="bookmark3"></a>ζ</span><span class="font25" style="font-style:italic;"><sub>l</sub></span></h2>
<h2><a name="bookmark4"></a><span class="font26" style="font-style:italic;"><a name="bookmark5"></a>ε</span></h2>
<p><span class="font21" style="font-style:italic;"><sup>l</sup> &nbsp;&nbsp;</span><span class="font26" style="font-style:italic;">ζ</span><span class="font21"> 0 </span><span class="font26">+ </span><span class="font26" style="font-style:italic;">ζ</span><span class="font21"> 1 </span><span class="font26">+........+ </span><span class="font26" style="font-style:italic;">ζ</span><span class="font21"> 2 </span><span class="font19" style="font-style:italic;">m</span><span class="font2"> -</span><span class="font21">1</span></p>
<p><span class="font25">dimana,</span></p>
<div>
<p><span class="font25">(15)</span></p>
</div><br clear="all">
<div>
<p><span class="font3" style="font-style:italic;">ζ</span><span class="font19" style="font-style:italic;">l</span><span class="font3"> =</span></p>
</div><br clear="all">
<div><img src="https://jurnal.harianregional.com/media/7245-8.png" alt="" style="width:37pt;height:20pt;">
</div><br clear="all">
<div><img src="https://jurnal.harianregional.com/media/7245-9.png" alt="" style="width:51pt;height:23pt;">
</div><br clear="all">
<p><span class="font22">jika0 </span><span class="font3">≤ </span><span class="font22">l </span><span class="font3">≤</span><span class="font22">2<sup>m-1</sup></span></p>
<p><span class="font22">jika0 </span><span class="font3">≤ </span><span class="font22">l</span><span class="font3">≤ </span><span class="font22">2<sup>m</sup></span></p>
<p><span class="font25">(16)</span></p>
<ul style="list-style:none;"><li>
<p><span class="font26">•</span><span class="font25"> &nbsp;&nbsp;&nbsp;Algoritma M-step</span></p></li></ul>
<p><span class="font25">Pada M-step, dekoder LDPC memperbaharui </span><span class="font25" style="font-style:italic;">θ </span><span class="font25">menggunakan </span><span class="font25" style="font-style:italic;">ψ</span><span class="font25"> yang telah dibangkitkan menggunakan metode </span><span class="font25" style="font-style:italic;">joint bitplane LDPC decoding</span><span class="font25"> [13].</span></p>
<p><span class="font5" style="font-style:italic;">θ</span><span class="font3"><sup>(</sup></span><span class="font20" style="font-style:italic;">t</span><span class="font3">) </span><span class="font24">:</span><span class="font5">= </span><span class="font24">arg max </span><span class="font24" style="font-style:italic;">P</span><span class="font11">{</span><span class="font24" style="font-style:italic;">Y</span><span class="font24">, </span><span class="font24" style="font-style:italic;">S</span><span class="font24">, </span><span class="font5">θ</span><span class="font11">}</span></p>
<p><span class="font1">Θ</span></p>
<p><span class="font5">= </span><span class="font24">arg max </span><span class="font9">∑ </span><span class="font24" style="font-style:italic;">P^</span><span class="font20" style="font-style:italic;">p</span><span class="font7"> {</span><span class="font24" style="font-style:italic;">M</span><span class="font5"> = </span><span class="font24" style="font-style:italic;">m</span><span class="font7"> } </span><span class="font24" style="font-style:italic;">P</span><span class="font11"> {</span><span class="font24" style="font-style:italic;">Y</span><span class="font24">, </span><span class="font24" style="font-style:italic;">S</span><span class="font14" style="font-style:italic;">∖</span><span class="font24" style="font-style:italic;">M</span><span class="font5"> = </span><span class="font24" style="font-style:italic;">m</span><span class="font24">, </span><span class="font5">θ</span><span class="font11">} </span><span class="font1">Θ</span></p>
<p><span class="font25">(17)</span></p>
<p><span class="font25">Sebelum dinormalisasi pada </span><span class="font26">ω</span><span class="font18">∈</span><span class="font26"> </span><span class="font25">{</span><span class="font25" style="font-style:italic;">0,</span><span class="font26">......,</span><span class="font25" style="font-style:italic;">2<sup>d</sup>-1</span><span class="font25">}, </span><span class="font25" style="font-style:italic;">θ</span><span class="font22" style="font-style:italic;">(<sup>t</sup></span><span class="font25"> dihitung</span></p>
<p><span class="font25">sebagai:</span></p>
<p><span class="font16" style="font-style:italic;">θ</span><span class="font16"><sup>(</sup></span><span class="font20" style="font-style:italic;">t</span><span class="font3">) </span><span class="font7">(</span><span class="font24" style="font-style:italic;">i</span><span class="font24">, </span><span class="font24" style="font-style:italic;">j</span><span class="font24">,</span><span class="font16" style="font-style:italic;">ω</span><span class="font7">) </span><span class="font24">:</span><span class="font5">= </span><span class="font16" style="font-style:italic;">ψ</span><span class="font16"><sup>(</sup></span><span class="font20" style="font-style:italic;">t</span><span class="font3">) </span><span class="font7">(</span><span class="font24" style="font-style:italic;">i</span><span class="font24">, </span><span class="font24" style="font-style:italic;">j</span><span class="font24">,</span><span class="font16" style="font-style:italic;">ω</span><span class="font7">)</span><span class="font29">∏</span><span class="font11">(</span><span class="font16" style="font-style:italic;">α</span><span class="font20" style="font-style:italic;">&lt;<sup>t</sup>^&quot;</span><span class="font19" style="font-style:italic;">g</span><span class="font0">&quot;<sup>]</sup> </span><span class="font11">(</span><span class="font24">1 </span><span class="font5">-</span><span class="font16" style="font-style:italic;">α</span><span class="font20" style="font-style:italic;">&lt;<sup>t</sup></span><span class="font3">)</span><span class="font11">)</span><span class="font20"><sup>1</sup></span><span class="font0" style="font-style:italic;"><sup>ω</sup></span><span class="font19" style="font-style:italic;">*</span><span class="font0">=</span><span class="font19"><sup>0</sup></span><span class="font0">J &nbsp;&nbsp;&nbsp;</span><span class="font25"><sup>(18)</sup></span></p>
<p><span class="font20" style="font-style:italic;">g</span><span class="font21">=</span><span class="font20"><sup>1</sup></span></p>
<p><span class="font25" style="font-style:italic;">dimana ω</span><span class="font22" style="font-style:italic;">g</span><span class="font25"> merupakan bit ke-</span><span class="font25" style="font-style:italic;">g</span><span class="font25"> dalam </span><span class="font25" style="font-style:italic;">Gray mapping</span><span class="font25"> dari nilai luminance </span><span class="font25" style="font-style:italic;">ω</span><span class="font25"> dan 1</span><span class="font22">[<sub>.</sub>] </span><span class="font25">merupakan fungsi indikator. M-step juga membangkitkan </span><span class="font25" style="font-style:italic;">hard estimate </span><span class="font22" style="font-style:italic;">X</span><span class="font22"><sup>ˆ</sup> </span><span class="font25">dengan mengambil satu nilai yang paling mungkin untuk setiap piksel yang sesuai dengan </span><span class="font25" style="font-style:italic;">θ</span><span class="font25">.</span></p>
<p><span class="font26">X </span><span class="font10">(</span><span class="font26" style="font-style:italic;">i</span><span class="font26">, </span><span class="font26" style="font-style:italic;">j</span><span class="font10"> ) </span><span class="font6">= </span><span class="font26">argmax </span><span class="font26" style="font-style:italic;"><sub>m</sub>θ</span><span class="font10"> (</span><span class="font26" style="font-style:italic;">i</span><span class="font26">, </span><span class="font26" style="font-style:italic;">j</span><span class="font26">, </span><span class="font26" style="font-style:italic;">ω</span><span class="font10">) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="font25"><sup>(1</sup>9)</span></p>
<p><span class="font25">dengan iterasi melalui M-step dan E-step, dekoder LDPC meminta bit-bit syndrome tambahan jika estimasi tidak konvergen. Algoritma berhenti ketika </span><span class="font25" style="font-style:italic;">hard estimate </span><span class="font21" style="font-style:italic;">X</span><span class="font25"><sup>ˆ </sup>menghasilkan syndrome yang identik dengan </span><span class="font25" style="font-style:italic;">S</span><span class="font25">.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font25">IV.</span><span class="font25" style="font-variant:small-caps;"> &nbsp;&nbsp;&nbsp;H</span><span class="font23" style="font-variant:small-caps;">asil </span><span class="font25" style="font-variant:small-caps;">D</span><span class="font23" style="font-variant:small-caps;">an </span><span class="font25" style="font-variant:small-caps;">P</span><span class="font23" style="font-variant:small-caps;">embahasan</span></p></li></ul>
<p><span class="font25">Pada bagian ini akan dibahas evaluasi kinerja RD codec WZVC DISCOVER dan WZVC-EM, masing-masing dengan menerapkan metode pembangkitan SI yang berbeda dimana telah dipaparkan pada bab sebelumnya. Pembahas kinerja RD dilihat dari hasil kedua codec yaitu codec dilihat dari hasil GOP 2, 4 dan 8 dari video Foreman (sequen video ini dijadikan video percobaan oleh [8] dan [10]). Video Foreman sendiri merupakan contoh video dengan gerak cepat.</span></p>
<p><span class="font25">Secara umum codec WZVC DISCOVER pada gambar 8 (a) menunjukkan penurunan kinerja RD terlihat dari penurunan grafik dengan menggunakan GOP ukuran 2, 4 dan 8. Hal ini menunjukkan bahwa teknik B-MCFI masih belum dapat berjalan dengan baik ketika GOP lebih besar dari 2 dimana korelasi temporal dengan pergerakkan cepat untuk Foreman belum mampu diestimasi. Jarak temporal frame</span></p>
<p><span class="font25">referensi berubah jauh sehingga sulit untuk diperkirakan frame selanjutnya yang terdapat di frame WZ.</span></p>
<div><img src="https://jurnal.harianregional.com/media/7245-10.jpg" alt="" style="width:243pt;height:123pt;">
<p><span class="font23">(a)</span></p>
</div><br clear="all"><img src="https://jurnal.harianregional.com/media/7245-11.jpg" alt="" style="width:136pt;height:110pt;">
<p><span class="font23">(b)</span></p>
<p><span class="font23">Gambar 8 Performa RD GOP 2 Foreman : (a) WZVC DISCOVER [8] dan</span></p>
<p><span class="font23">(b) WZVC-EM [10]</span></p>
<p><span class="font25">Gambar 8 (b) WZVC-EM menunjukkan bahwa terjadi peningkatan grafik pada GOP ukuran lebih dari 2, pada hal ini peningkatan ini disebabkan oleh medan gerak yang terus diperbaharui (interaktif) dan motion field yang diperbaiki terus menerus. Teknik pembelajaran tanpa supervisi medan gerak ini melakukan perbaikan estimasi medan gerak secara kontinyu sehingga frame SI kompensasi (soft SI) mampu mendekati frame WZ. Kondisi ini menyebabkan codec WZVC-EM mampu meningkatkan kinerja RD terutama pada ukuran GOP lebih besar dibandingkan codec WZVC DISCOVER.</span></p>
<ul style="list-style:none;"><li>
<p><span class="font25">V. &nbsp;</span><span class="font25" style="font-variant:small-caps;">K</span><span class="font23" style="font-variant:small-caps;">esimpulan</span></p></li></ul>
<p><span class="font25">Paper ini telah memaparkan dan menjelaskan skema berbeda pada pembangkitan soft SI yang digunakan pada setiap codec WZVC, mulai dari metode </span><span class="font25" style="font-style:italic;">Motion-Compesated Frame Interpolation/ Extrapolation</span><span class="font25"> (MCFI/E) pada codec WZVC Stanford, </span><span class="font25" style="font-style:italic;">Bidirectional Motion-Compensated Frame Interpolation</span><span class="font25"> (B-MCFI) pada codec DISCOVER, sampai skema pembelajaran tanpa supervisi medan gerak pada codec WZVC-EM. Teknik pembelajaran tanpa supervisi medan gerak melakukan perbaikan estimasi medan gerak secara terus-menerus sehingga frame SI kompensasi (soft SI) mampu mendekati frame WZ. Kondisi ini menyebabkan codec WZVC-EM mampu meningkatkan kinerja RD terutama pada ukuran GOP lebih besar dibandingkan codec WZVC Discover.</span></p>
<p><span class="font25">Semakin akurat Soft SI semakin identik dengan frame WZ, dalam paper ini dapat diketahui bahwa pada codec</span></p>
<p><span class="font25">WZVC DISCOVER dengan mengunakan metode </span><span class="font25" style="font-style:italic;">Bidirectional Motion-Compensated Frame Interpolation</span><span class="font25"> (B-MCFI) hanya mampu bekerja baik pada GOP 2, hal ini menyebabkan enkoder bekerja lebih banyak dibandingkan Codec WZVC-EM. Dari hasil ini, pengembangan codec WZVC sebaiknya diarahkan pada sistem pembelajaran di SI yang nantinya akan mampu memperbarui medan gerak awal untuk menghasilkan medan gerak baru untuk menambah kinerja RD dan mengurangi beban di enkoder.</span></p>
<p><span class="font25" style="font-variant:small-caps;">R</span><span class="font23" style="font-variant:small-caps;">eferensi</span></p>
<ul style="list-style:none;"><li>
<p><span class="font23">[1] &nbsp;&nbsp;&nbsp;Slepian, D. dan Wolf, J.K., “Noiseless Coding of Correlated Information Sources”, </span><span class="font23" style="font-style:italic;">IEEE Transaction Information Theory</span><span class="font23">, Vol. IT-19, No.4, hal. 471– 480, Jul.1973.</span></p></li>
<li>
<p><span class="font23">[2] &nbsp;&nbsp;&nbsp;Wyner, A.D. dan Ziv, J., “The Rate-Distortion Function for Source Coding with Side Information at the Dekoder”, IEEE Transaction. Information Theory, Vol. IT-22, No. 1, hal. 1–10, Jan.1976.</span></p></li>
<li>
<p><span class="font23">[3] &nbsp;&nbsp;&nbsp;Girod, B., Aaron, A., Rane, S., dan Monedero, D.R., “Distributed Video Coding”, </span><span class="font23" style="font-style:italic;">Proceedings of IEEE, Spscial Issue on Advances in Video Coding and Delivery</span><span class="font23">, Vol. 93, No. 1, hal. 71-83, Jan. 2005.</span></p></li>
<li>
<p><span class="font23">[4] &nbsp;&nbsp;&nbsp;Aaron, A., Zhang, R., dan Girod, B.,“Wyner-Ziv Coding of Motion Video”, </span><span class="font23" style="font-style:italic;">Asilomar Conference on Signals, Systems and Computer</span><span class="font23">, Pacific Grove, USA, Vol. 1, hal. 240-244, 3-6 Nov. 2002</span></p></li>
<li>
<p><span class="font23">[5] &nbsp;&nbsp;&nbsp;Aaron, A., Rane, S., Setton, E. dan Girod, B.,“Transform Domain Wyner-Ziv Codec for Video“, </span><span class="font23" style="font-style:italic;">Proceedings of SPIE in Visual Communications and Image Processing</span><span class="font23">, San Jose, California, USA, Vol. 5308, hal. 520–528, Jan.2004.</span></p></li>
<li>
<p><span class="font23">[6] &nbsp;&nbsp;&nbsp;Artigas, X., Ascenso, J., Dalai, M., Klomp, S., Kubasov, D. dan Ouaret, M. , “The DISCOVER Codec: Architecture, Techniques and Evaluation”, </span><span class="font23" style="font-style:italic;">Proceedings of Picture Coding Symposium</span><span class="font23">, Lisbon, Portugal, 2007.</span></p></li>
<li>
<p><span class="font23">[7] &nbsp;&nbsp;&nbsp;Varodayan, D.,”Adaptive Distributed Source Coding”, Desertasi Ph.D. Stanford University, 2010.</span></p></li>
<li>
<p><span class="font23">[8] &nbsp;&nbsp;&nbsp;Kubasov, D., Nayak, J. dan Guillemot, C., “Optimal Reconstruction in Wyner-Ziv Video Coding with Multiple Side Information”, </span><span class="font23" style="font-style:italic;">Proceedings of IEEE International Workshop Multimedia Signal Processing</span><span class="font23">, Chania, Greece, hal. 183-186, 2007.</span></p></li>
<li>
<p><span class="font23">[9] &nbsp;&nbsp;&nbsp;Pereira,F., Ascenso, J., Brites, C., “ Studying the GOP Size Impact on the Performance of Feedback Channel-based Wyner-Ziv Video Codec”, IEEE </span><span class="font23" style="font-style:italic;">Pacific Rim Symposium on Image Video and Technology, Santiago, Chile, December 2007.</span></p></li>
<li>
<p><span class="font23">[10] &nbsp;&nbsp;&nbsp;Ascenso, J., Brites, C. dan Pereira, F. “Content Adaptive Wyner-Ziv Video Coding Driven by Motion Activity, </span><span class="font23" style="font-style:italic;">Proceedings of IEEE International Conference Image Processing”</span><span class="font23">, Atlanta, Georgia, 2006.</span></p></li>
<li>
<p><span class="font23">[11] &nbsp;&nbsp;&nbsp;Ascenso, J., Brites, C. dan Pereira, F. (2005), “Improving Frame Interpolation with Spatial Motion Smoothing for Pixel Domain Distributed Video Coding“, </span><span class="font23" style="font-style:italic;">Proceedings of EURASIP Conference Speech Image Processing, Multimedia Commuication Services</span><span class="font23">, Smolenice, Slovak Republic, 2005.</span></p></li>
<li>
<p><span class="font23">[12] &nbsp;&nbsp;&nbsp;Varodayan, D., Chen, D., Flierl, M. dan Girod, B., “Wyner-Ziv Coding of Video with Unsupervised Motion Vector Learning”, </span><span class="font23" style="font-style:italic;">EURASIP Signal Processing: Image Communication Journal, Special Issue on Distributed Video Coding,</span><span class="font23"> Vol. 23, No. 5, hal. 369-378, Jun.2008.</span></p></li>
<li>
<p><span class="font23">[13] &nbsp;&nbsp;&nbsp;Varodayan, D., Mavlankar, A., Flierl, M. dan Girod, B. (2006), “Distributed Coding of Random Dot Stereogram with Unsupervised Learning of Disparity”, </span><span class="font23" style="font-style:italic;">Proceedings of IEEE International Workshop Multimedia Signal Processing</span><span class="font23">, hal. 5-8</span></p></li></ul>
<p><span class="font25">108</span></p>
<p><span class="font5">ISBN: 978-602-7776-72-2 © Universitas Udayana 2013</span></p>